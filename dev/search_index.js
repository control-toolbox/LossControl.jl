var documenterSearchIndex = {"docs":
[{"location":"zermelo1.html#Zermelo-problem,-example-1","page":"Zermelo example 1","title":"Zermelo problem, example 1","text":"","category":"section"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"We consider the Zermelo-type optimal control problem with loss control regions given by","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"    beginequation\n    beginarraylcl\n     textminimize  -x_1(8)10pt\n     textsubject to   (xu) in mathrmAC(08R^2) times mathrmL^infty(08R) 6pt\n       dotx_1(t) = x_2(t) + cos(u(t)) quad textae  tin 08 6pt\n       dotx_2(t) = sin(u(t)) quad textae  tin 08 6pt\n        x(0)=0_R^2 quad x_2(8)=4  6pt\n        u(t) in -fracpi2fracpi2 quad textae  tin 08 6pt\n       u text is constant when  x text is in the loss control region \n     x in mathbbR^2 mid 05  x_2  35 \n    endarray\n    endequation","category":"page"},{"location":"zermelo1.html#Reformulation-for-the-direct-method","page":"Zermelo example 1","title":"Reformulation for the direct method","text":"","category":"section"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"    left\n    beginarrayl\n    displaystyle min - x_1(8) + varepsilonint_0^8 v^2(t)dt + int_0^1 f_NC(x(t))u^2(t)dt 05em\n    dotx_1(t) = f_C(x(t))(x_2(t) + cos(u(t))) + f_NC(x_2(t) + cos(lambda(t)))  textfor ae  tin 0805em\n    dotx_2(t) = f_C(x(t))sin(u(t)) + f_NC(x(t))sin(lambda(t))   textfor ae  tin 08 05em\n    dotlambda(t) = f_C(x(t))v^2(t)   textfor ae  tin 08 05em\n\n    u(t) in -fracpi2 fracpi2  textfor ae  tin 08 05em\n    x(0) = 0_mathbbR^2 quad x_2(8) = 405em\n    x in mathbbR^2 mid 05  x_2  35  text is a loss control region\n    endarray\n    right","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"using JuMP \nusing Ipopt\nusing Plots\nusing Plots.PlotMeasures\nusing LaTeXStrings","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"mutable struct Direct\n    t; x1; x2 ; λ ; u ; xu ; xv ; p1 ; p2\nend\n\nmutable struct DirecttSol\n    t; x1; x2 ; λ ; u ; v ; xu ; xv ; p1 ; p2 ; p3 \nend","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"distance_squared(x, a, b) = x < a ? (a - x)^2 : x > b ? (x - b)^2 : 0 ;\n\n# Moreau Yosida regularization\nfunction MY_reg(x, a, b, k)\n    return 1 - exp(-k*distance_squared(x, a, b))\nend\n\nfC(x) = MY_reg(x, 0.5, 3.5, 2000)\nfNC(x) = 1 - fC(x)\n\nplot(fNC, 0, 5)","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"function ZERMELO(ε=1e-3; x0=[0, 0], nsteps=1000, tol=1e-10, display=true)\n    \"\"\"\n        Solve the Zermelo problem with the given parameters.\n\n        Parameters\n        ----------\n\n        x0 : array of floats\n            Initial condition\n        nsteps : int\n            Number of steps in the discretization\n        ε : float\n            Regularization parameter\n        tol : float\n            Tolerance for the solver\n        display : bool\n            If true, display the results\n\n        Returns\n        -------\n    \n        sol : DirecttSol\n            The (direct) solution of the problem\n\n    \"\"\"\n\n    # Create JuMP model, using Ipopt as the solver\n    sys = Model(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => display ? 5 : 1))\n    set_optimizer_attribute(sys,\"tol\", tol)\n    set_optimizer_attribute(sys,\"constr_viol_tol\", tol)\n    set_optimizer_attribute(sys,\"max_iter\", 200)\n\n    # Constants\n    N  = nsteps     # Grid size\n\n    # Variables\n    @variables(sys, begin\n        x1[1:N+1]\n        x2[1:N+1]\n        -2  ≤  λ[1:N+1]  ≤ 2 # we add box constraints to help the convergence\n        -2  ≤  u[1:N+1]  ≤ 2\n        v[1:N+1]\n        xv[1:N+1]\n        xu[1:N+1]\n    end)\n\n    # Objective\n    @NLobjective(sys, Min, -x1[N+1] + ε*xv[N+1] + xu[N+1])\n\n    # Boundary constraints\n    @constraints(sys, begin\n        con_xu0, xu[1]   == 0\n        con_xv0, xv[1]   == 0\n        con_x10, x1[1]   == x0[1]\n        con_x20, x2[1]   == x0[2]\n        con_x2f, x2[N+1] == 4\n        end)\n\n    # Expressions for the dynamics\n    @NLexpression(sys, dx1[j = 1:N+1], x2[j] + fNC(x2[j])*cos(λ[j]) + fC(x2[j])*cos(u[j]))\n    @NLexpression(sys, dx2[j = 1:N+1],         fNC(x2[j])*sin(λ[j]) + fC(x2[j])*sin(u[j]))\n    @NLexpression(sys,  dλ[j = 1:N+1], fC(x2[j])*v[j])\n    @NLexpression(sys, dxv[j = 1:N+1], v[j]^2)\n    @NLexpression(sys, dxu[j = 1:N+1], fNC(x2[j])*u[j]^2)\n\n    # Dynamics with Crank-Nicolson scheme\n    Δt = 8/(N+1)\n    @NLconstraints(sys, begin\n    con_dx1[j=1:N], x1[j+1] == x1[j] + 0.5 * Δt * (dx1[j+1] + dx1[j])\n    con_dx2[j=1:N], x2[j+1] == x2[j] + 0.5 * Δt * (dx2[j+1] + dx2[j])\n    con_dx3[j=1:N],  λ[j+1] ==  λ[j] + 0.5 * Δt * (dλ[j+1]  + dλ[j])\n    con_dxv[j=1:N], xv[j+1] == xv[j] + 0.5 * Δt * (dxv[j+1] + dxv[j])\n    con_dxu[j=1:N], xu[j+1] == xu[j] + 0.5 * Δt * (dxu[j+1] + dxu[j])\nend);\n\nif display\n    println(\"Solving...\")\nend\nstatus = optimize!(sys)\nif display\n    println()\nend\n    \n# Display results\nif display\n    if termination_status(sys) == MOI.OPTIMAL\n        println(\"  Solution is optimal\")\n    elseif  termination_status(sys) == MOI.LOCALLY_SOLVED\n        println(\"  (Local) solution found\")\n    elseif termination_status(sys) == MOI.TIME_LIMIT && has_values(sys)\n        println(\"  Solution is suboptimal due to a time limit, but a primal solution is available\")\n    else\n        error(\"  The model was not solved correctly.\")\n    end\n    println(\"  objective value = \", objective_value(sys))\n    println()\nend    \n    \n# Retrieves values (including duals)\nx1 = value.(x1)[:]\nx2 = value.(x2)[:]\nλ  = value.(λ)[:]\nu  = value.(u)[:]\nv  = value.(v)[:]\nxu  = value.(xu)[:]\nxv  = value.(xv)[:]\nt  = (0:N) * value.(Δt)\n\n# duals of the boundary constraints\npx10 = -dual(con_x10)\npx20 = -dual(con_x20)\npx30 = 0 # λ(0) is free\npx1f = 1\npx2f = dual(con_x2f) \npx3f = 0 # λ(4) is free\n\n# duals of the dynamics\npx1 = -[ dual(con_dx1[i]) for i in 1:N ]\npx2 = -[ dual(con_dx2[i]) for i in 1:N ]\npx3 = -[ dual(con_dx3[i]) for i in 1:N ]\n\n# adjoint vectors\np1 = [px10; (px1[1:N-1]+px1[2:N])/2; px1f]\np2 = [px20; (px2[1:N-1]+px2[2:N])/2; px2f]\np3 = [px30; (px3[1:N-1]+px3[2:N])/2; px3f]\n\nreturn DirecttSol(t, x1, x2, λ, u, v, xu, xv, p1, p2, p3)\n    \nend;","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# Resolution\nε = 1e-3\nsol_direct = ZERMELO(ε);","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# Plots\nt  = sol_direct.t\nx1 = sol_direct.x1\nx2 = sol_direct.x2\nu  = sol_direct.u\nv  = sol_direct.v\nλ  = sol_direct.λ\nxu = sol_direct.xu\nxv = sol_direct.xv\np1 = sol_direct.p1\np2 = sol_direct.p2\np3 = sol_direct.p3\n\nprintln(\"xu = \", xu[end])\nprintln(\"xv = \", xv[end])\n\nu1     = deepcopy(u); \nindex1 = findfirst(abs.(x2.- 0.5) .< 0.01)\nindex2 = findfirst(abs.(x2.- 3.5) .< 0.01)\nt1   = t[index1-1]\nt2   = t[index2+2]\nu1[t1  .<= t .<= t2] .= λ[(index1 + index2) ÷ 2]\n\n# plots\nx1_plot   = plot(t, x1, label=\"x₁(t)\", linecolor=:blue, linewidth=2)\n\nx2_plot   = plot(t,  x2, label=\"x₂(t)\", linecolor=:blue, linewidth=2)\nxticks!(x2_plot, [t1,2.,t2,6.,8.], [L\"$\\tau_1$\", \"2\",L\"$\\tau_2$\",\"6\",\"8\"])\nvline!(x2_plot, [t1], linestyle=:dash, linecolor=:gray, label=nothing)\nvline!(x2_plot, [t2], linestyle=:dash, linecolor=:gray, label=nothing)\nhline!([(0., 0.5), (8., 0.5)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 3.5), (8., 3.5)], linecolor=:black, linewidth=2, label=false)\n\np1_plot   = plot(t, p1, label=\"p₁(t)\", linecolor=:orange, linewidth=2, ylims=(0.5, 1.5))\n\np2_plot   = plot(t,  p2, label=\"p₂(t)\", linecolor=:orange, linewidth=2)\nxticks!(p2_plot, [t1,2.,t2,6.,8.], [L\"$\\tau_1$\", \"2\",L\"$\\tau_2$\",\"6\",\"8\"])\nvline!(p2_plot, [t1], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p2_plot, [t2], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\nu_plot = plot(t,  u1, label=\"u(t)\" ,linecolor=:red ,linewidth=2, ylims=(-1.5, 1.5))\nplot!(t, λ, label=\"λ(t)\", linecolor=:brown , linewidth=2)\nxticks!(u_plot, [t1,2.,t2,6.,8.], [L\"$\\tau_1$\", \"2\",L\"$\\tau_2$\",\"6\",\"8\"])\nvline!(u_plot, [t1], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [t2], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\nx1x2_plot = plot(x1, x2, xlabel = \"x₁\", ylabel = \"x₂\",   legend=false, linecolor=:blue, linewidth=2)\nplot!(x1x2_plot, [0., 32.], [0.5, 0.5], fillrange = 0.0, fillalpha = 0.2, fillcolor = :green, label=false )\nplot!(x1x2_plot, [0., 32.], [3.5, 3.5], fillrange = 0.5, fillalpha = 0.2, fillcolor = :red,  label=false )\nplot!(x1x2_plot, [0., 32.], [5.5, 5.5], fillrange = 3.5, fillalpha = 0.2, fillcolor = :green, label=false )\nhline!([(0., 0.5), (32., 0.5)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 3.5), (32., 3.5)], linecolor=:black, linewidth=2, label=false)\nxlims!(0, 31)\n\n# global plot\nplot(x1x2_plot, x1_plot, x2_plot, u_plot , p1_plot, p2_plot , layout = (2,3), size=(900, 600))","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# other plots specific to the direct method\n\nv_plot   = plot(t,  v, label = \"v(t)\", linecolor=:purple, linewidth=2, ylims=(-1, 0.5))\nxticks!(v_plot, [t1,2.,t2,4.,6.,8.], [L\"$\\tau_1$\", \"2\",L\"$\\tau_2$\",\"4\",\"6\",\"8\"])\nvline!(v_plot, [t1], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(v_plot, [t2], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\n\np3_plot   = plot(t,  p3, label = \"pλ(t)\", linecolor=:orange, linewidth=2)\nxticks!(p3_plot, [t1,2.,t2,4.,6.,8.], [L\"$\\tau_1$\", \"2\",L\"$\\tau_2$\",\"4\",\"6\",\"8\"])\nvline!(p3_plot, [t1], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(p3_plot, [t2], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\n\nplot(v_plot,p3_plot ,p1_plot,p2_plot, layout = (2,2), size=(900, 500), left_margin=10mm)","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"function H(k)\n    return p1[k] * x2[k] + p1[k] * (fNC(x2[k])*cos(λ[k]) + fC(x2[k])*cos(u[k])) +\n                        p2[k] * (fNC(x2[k])*sin(λ[k]) + fC(x2[k])*sin(u[k])) +\n                        p3[k] * fC(x2[k]) * v[k] -\n                        ε * v[k]^2 - fNC(x2[k]) * u[k]^2\nend\n\nH_direct  = [H(k) for k in 1:length(x1)]\nph_plot   = plot(t, H_direct, label = \"H(t): direct\", linecolor=:green , linewidth=2, ylims=(5.5, 7))","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"jmp1 = p2[index1+2]  - p2[index1]\njmp2 = p2[index2+2]  - p2[index2]\n\nprintln(\" p2(t1+) - p2(t1-) = \", jmp1)\nprintln(\" p2(t2+) - p2(t2-) = \", jmp2)","category":"page"},{"location":"zermelo1.html#Indirect-method","page":"Zermelo example 1","title":"Indirect method","text":"","category":"section"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"using NLsolve\nusing Animations\nusing Reel\nusing Plots\nusing Plots.PlotMeasures\nusing LinearAlgebra\ninclude(\"flow.jl\");","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# Dynamics\nfunction F(x, u)\n    return [ x[2] + cos(u), sin(u) ]\nend\n\nfunction G(λ)\n    return [ sin(λ), - cos(λ) ]\nend\n\n# Hamiltonian: permanent region\nH1(x, u, p)  = p' * F(x, u)                 # pseudo-Hamiltonian\nu11(x, p)    = atan(p[2]/p[1])              # maximizing control\nHc(x, p)     = H1(x, u11(x, p) , p )        # Hamiltonian\n\n# Flow\nfc  = Flow(Hc)\n\n# Hamiltonian: control loss region\nH2(x, λ, y, p)   = p' * F(x, λ)   + y* p' *G(λ) # pseudo-Hamiltonian\nHcl(X, P)     = H2(X[1:2], X[3], X[4], P[1:2])  # Hamiltonian\n\n# Flow\nfcl  = Flow(Hcl);","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# parameters\nt0  = 0\ntf  = 8\nx2f = 4\nx0  = [0, 0]\n\n# Shooting function\nfunction shoot(p0, tt1, tt2, λ, jump1, jump2) \n    \n    pλ0    = 0\n    py0    = 0\n    \n    x1, p1 = fc(t0, x0, p0, tt1)\n    X2, P2 = fcl(tt1, [x1; λ; 0], [p1 - [0, jump1]; pλ0; py0], tt2) # augmented flow\n    xf, pf = fc(tt2, X2[1:2], P2[1:2] - [0, jump2], tf)\n\n    s = zeros(eltype(p0), 7)\n    s[1]  = xf[2] - x2f # target\n    s[2]  = pf[1] - 1.0 # transversality condition\n    s[3]  = x1[2] - 0.5 # first crossing \n    s[4]  = X2[2] - 3.5 # second crossing \n    s[5]  = P2[4]       # averaged gradient condition\n    s[6]  = jump1 - (p1[1]*(cos(λ) - cos(u11(x1, p1)))           + \n                    p1[2]*(sin(λ) - sin(u11(x1, p1))))/(sin(λ))                                              # jump 1\n    s[7]  = jump2 - (P2[1]*(cos(u11(X2[1:2], P2[1:2])) - cos(λ)) + \n                    P2[2]*(sin(u11(X2[1:2], P2[1:2])) - sin(λ)))/(sin(u11(X2[1:2], P2[1:2])))                # jump 2\n\n    return s\n\nend;","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# Solve\n\nS(ξ)    = shoot(ξ[1:2], ξ[3], ξ[4], ξ[5], ξ[6], ξ[7])\nξ_guess = [p1[1], p2[1], t1[1], t2[1], λ[(index1+index2)÷2], jmp1, jmp2] # initial guess\nprintln(\"Initial value of shooting:\\n\", S(ξ_guess), \"\\n\\n\")\n\nindirect_sol = nlsolve(S, ξ_guess; xtol=1e-8, method=:trust_region, show_trace=true)\nprintln(indirect_sol)\n\n# Retrieves solution\nif indirect_sol.f_converged || indirect_sol.x_converged\n    pp0   = indirect_sol.zero[1:2]\n    tt1   = indirect_sol.zero[3]\n    tt2   = indirect_sol.zero[4]\n    a     = indirect_sol.zero[5]\n    jmp11 = indirect_sol.zero[6]\n    jmp22 = indirect_sol.zero[7]\n\nelse\n    error(\"Not converged\")\nend;","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"Initial value of shooting: [0.05007226071378135, 0.0, -0.011617047560808114, 0.013492751980266338, 0.2568239312461033, -0.3251275640733963, 0.3085873259832842]","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"Iter     f(x) inf-norm    Step 2-norm  –––   –––––––   –––––––         0     3.251276e-01              NaN         1     2.901690e-03     4.423209e-01         2     2.455838e-06     3.474638e-03         3     3.406229e-13     5.064949e-07 Results of Nonlinear Solver Algorithm     * Algorithm: Trust-region with dogleg and autoscaling     * Starting Point: [1.0, 6.087321019322859, 0.4955044955044955, 3.612387612387612, 1.3275286734022251, -0.337988685006648, 0.3238832176238047]     * Zero: [1.0, 6.088879620621635, 0.5073023447991126, 3.5974522435428518, 1.3286547556171466, -0.01228198993970171, 0.027541288724319064]     * Inf-norm of residuals: 0.000000     * Iterations: 3     * Convergence: true     * |x - x'| < 1.0e-08: false     * |f(x)| < 1.0e-08: true     * Function Calls (f): 4     * Jacobian Calls (df/dx): 4","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# jumps from direct solution\nprintln(\" jumps from direct solution\")\nprintln(\" p2(t1+) - p2(t1-) = \", jmp1)\nprintln(\" p2(t2+) - p2(t2-) = \", jmp2)\nprintln(\"\")\n\n# jumps from indirect solution\nprintln(\" jumps from indirect solution\")\nprintln(\" p2(t1+) - p2(t1-) = \", jmp11)\nprintln(\" p2(t2+) - p2(t2-) = \", jmp22)","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"ode_sol = fc((t0, tt1), x0, pp0, saveat=0.1) ;\nttt1 = ode_sol.t ;\nxx1 = [ ode_sol[1:2, j] for j in 1:size(ttt1, 1) ] ;\npp1 = [ ode_sol[3:4, j] for j in 1:size(ttt1, 1) ] ;\nuu1 = u11.(xx1, pp1)  ;\n\npλ0 = 0. \npy0 = 0.\n\node_sol = fcl((tt1, tt2), [xx1[end] ; a ; 0.0], [pp1[end] - [0. , jmp11]; pλ0 ; py0], saveat=0.1)\nttt2 = ode_sol.t\nxx2 = [ ode_sol[1:2, j] for j in 1:size(ttt2, 1) ]\npp2 = [ ode_sol[5:6, j] for j in 1:size(ttt2, 1) ]\nuu2 = a.*ones(length(ttt2)) ;\n\node_sol = fc((tt2, tf), xx2[end], pp2[end] - [0. , jmp22], saveat=0.1)\nttt3 = ode_sol.t\nxx3 = [ ode_sol[1:2, j] for j in 1:size(ttt3, 1) ]\npp3 = [ ode_sol[3:4, j] for j in 1:size(ttt3, 1) ] \nuu3 = u11.(xx3, pp3)  ;\n\nt = [ ttt1 ; ttt2 ; ttt3 ]\nx = [ xx1 ; xx2 ; xx3 ]\np = [ pp1 ; pp2 ; pp3 ]\nu = [ uu1 ; uu2 ; uu3 ]\n\nm = length(t)\n\nx1 = [ x[i][1] for i=1:m ]\nx2 = [ x[i][2] for i=1:m ]\np1 = [ p[i][1] for i=1:m ]\np2 = [ p[i][2] for i=1:m ];\n\nx1_plot   = plot(t, x1, label=\"x₁(t)\", linecolor=:blue, linewidth=2)\n\nx2_plot   = plot(t,  x2, label=\"x₂(t)\", linecolor=:blue, linewidth=2)\nxticks!(x2_plot, [ttt1[end],2.,ttt2[end],6.,8.], [L\"$\\tau_1^*$\", \"2\",L\"$\\tau_2^*$\",\"6\",\"8\"])\nvline!(x2_plot, [ttt1[end]], linestyle=:dash, linecolor=:gray, label=nothing)\nvline!(x2_plot, [ttt2[end]], linestyle=:dash, linecolor=:gray, label=nothing)\nhline!([(0., 0.5), (8., 0.5)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 3.5), (8., 3.5)], linecolor=:black, linewidth=2, label=false)\n\np1_plot   = plot(t, p1, label=\"p₁(t)\", linecolor=:orange, linewidth=2, ylims=(0.5, 1.5))\n\np2_plot   = plot(t,  p2, label=\"p₂(t)\", linecolor=:orange, linewidth=2)\nxticks!(p2_plot, [ttt1[end],2.,ttt2[end],6.,8.], [L\"$\\tau_1^*$\", \"2\",L\"$\\tau_2^*$\",\"6\",\"8\"])\nvline!(p2_plot, [ttt1[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p2_plot, [ttt2[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\nu_plot    = plot(t,   u, label=\"u(t)\" ,linecolor=:red ,linewidth=2, ylims=(-1.5, 2))\nxticks!(u_plot, [ttt1[end],2.,ttt2[end],6.,8.], [L\"$\\tau_1^*$\", \"2\",L\"$\\tau_2^*$\",\"6\",\"8\"])\nvline!(u_plot, [ttt1[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [ttt2[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\nx1x2_plot = plot(x1, x2, xlabel = \"x₁\", ylabel = \"x₂\",   legend=false, linecolor=:blue, linewidth=2)\nplot!(x1x2_plot, [0., 31.], [0.5, 0.5], fillrange = 0.0, fillalpha = 0.2, fillcolor = :green, label=false)\nplot!(x1x2_plot, [0., 31.], [3.5, 3.5], fillrange = 0.5, fillalpha = 0.2, fillcolor = :red, label=false)\nplot!(x1x2_plot, [0., 31.], [5.5, 5.5], fillrange = 3.5, fillalpha = 0.2, fillcolor = :green, label=false)\nhline!([(0., 0.5), (31., 0.5)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 3.5), (31., 3.5)], linecolor=:black, linewidth=2, label=false)\nxlims!(0, 31)\n\nx = plot(x1x2_plot,x1_plot, x2_plot,u_plot,p1_plot, p2_plot , layout = (2, 3), size=(900, 600))\n\n\n","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"function HH(k)\n    return p1[k] * (x2[k] + cos(u[k])) + p2[k] * sin(u[k])\nend\n\nH_indirect  = [HH(k) for k in 1:length(x2)]\nph_plot   = plot(t, H_indirect, label = \"H(t): indirect\", linecolor=:green , linewidth=2, ylims=(5.5, 7))","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"p2_plot = plot(t, p2, xlabel = \"t\", ylabel = \"p2\", legend=false, linecolor=:orange, linewidth=2)\nxticks!(p2_plot, [ttt1[end], 2., ttt2[end], 6., 8.], [L\"$\\tau_1^*$\", \"2\", L\"$\\tau_2^*$\", \"6\", \"8\"])\n\nxlims!(p2_plot, (ttt1[end]-0.05, ttt1[end]+0.05))\nylims!(p2_plot, (5.50, 5.65))\n","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"p2_plot = plot(t, p2, xlabel = \"t\", ylabel = \"p2\", legend=false, linecolor=:orange, linewidth=2)\nxticks!(p2_plot, [ttt1[end], 2., ttt2[end], 6., 8.], [L\"$\\tau_1^*$\", \"2\", L\"$\\tau_2^*$\", \"6\", \"8\"])\n\nxlims!(p2_plot, (ttt2[end]-0.05, ttt2[end]+0.05))\nylims!(p2_plot, (2.4250,2.55))","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# create an animation\nanimx = @animate for i = 1:length(t)\n    plot(x1[1:i], x2[1:i], xlim=(0.,31.), ylim=(-0.,5.5), xlabel=\"x1\", ylabel=\"x2\", label=\"optimal trajectory \\$x\\$\", linecolor=:blue,  linewidth=2)\n    scatter!([x1[i]], [x2[i]], markersize=4, marker=:circle, color=:black, label=false)\n    plot!( [0., 31.], [0.5, 0.5], fillrange = 0.0, fillalpha = 0.2, fillcolor = :green, label=false)\n    plot!( [0., 31.], [3.5, 3.5], fillrange = 0.5, fillalpha = 0.2, fillcolor = :red, label=false)\n    plot!( [0., 31.], [5.5, 5.5], fillrange = 3.5, fillalpha = 0.2, fillcolor = :green, label=false)\n\nend\n\n# create an animation\nanimu = @animate for i = 1:length(t)\n    plot(t[1:i], u[1:i], xlim=(0.,8.), ylim=(-pi/2,pi/2), xlabel=\"t\", ylabel=\"u\", label=\"opitmal control \\$u\\$\", linecolor=:red,  linewidth=2)\nend ;\n\n# create an animation\nanimp1 = @animate for i = 1:length(t)\n    plot(t[1:i], p1[1:i], xlim=(0.,8.), ylim=(0.,2.), xlabel=\"t\", ylabel=\"p1\", label=\"adjoint vector \\$p1\\$\", linecolor=:orange,  linewidth=2)\nend ;\n\n# create an animation\nanimp2 = @animate for i = 1:length(t)\n    plot(t[1:i], p2[1:i], xlim=(0.,8.), ylim=(-2.2,6.), xlabel=\"t\", ylabel=\"p2\", label=\"adjoint vector \\$p2\\$\", linecolor=:orange,  linewidth=2)\nend ;","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# display the animation\ngif(animx, \"zer1_x.gif\", fps = 10)","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"gif(animu, \"zer1_u.gif\", fps = 10)","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# display the animation\ngif(animp1, \"zer1_p1.gif\", fps = 10)","category":"page"},{"location":"zermelo1.html","page":"Zermelo example 1","title":"Zermelo example 1","text":"# display the animation\ngif(animp2, \"zer_p2.gif\", fps = 10)","category":"page"},{"location":"ho.html#Harmonic-oscillator-problem","page":"Harmonic oscillator","title":"Harmonic oscillator problem","text":"","category":"section"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"    left\n    beginarrayl\n        displaystyle min  T 05em\n        dotx_1(t) = x_2(t)  tin 0T05em\n        dotx_2(t) = u(t)-x_1(t) tin 0T  05em\n        u(t) in -1 1  tin 0T05em\n        x(0) = (420)  quad x(T) = 0_mathrmR^2 05em\n        x mid x_2  0 text is a control loss reigon\n    endarray\n    right","category":"page"},{"location":"ho.html#Reformulation-for-the-direct-method","page":"Harmonic oscillator","title":"Reformulation for the direct method","text":"","category":"section"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"    left\n    beginarrayl\n        displaystyle min  T + varepsilon int_0^T v^2(t)dt + int_0^T f_NC(x_2(t))u^2(t)dt 05em\n        dotx_1(t) = x_2(t)  tin 0T05em\n        dotx_2(t) =f_C(x_2(t))(u(t) - x_1(t)) + f_NC(x_2(t))(lambda(t) - x_1(t))\n         tin 0T  05em\n        dotlambda(t) = f_C(x_2(t))v(t) tin 0T05em\n        u(t) in -1 1  tin 0T05em\n        x(0) = (420)  quad x(T) = 0_mathrmR^2\n    endarray\n    right","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"using JuMP  \nusing Ipopt\nusing Plots\nusing LaTeXStrings\nusing Plots.PlotMeasures","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"mutable struct Direct\n    t; x1; x2 ; λ ; u ; xu ; xv ; p1 ; p2\nend\n\nmutable struct DirecttSol\n    t; x1; x2 ; λ ; u ; v ; xu ; xv ; p1 ; p2 ; p3\nend","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"distance_squared(x, a) = x < a ? (a - x)^2 : 0 ;\n\n#Moreau Yosida regularization\nfunction MY_reg(x, a, k)\n    return 1 - exp(-k*distance_squared(x, a))\nend\n\nfNC(x) = MY_reg(x, 0.03, 900)\nfC(x) = 1. - fNC(x)\n\nplot(fNC, -0.5, 0.5)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"function HO(ε=1e-3; x0=[2.5, 4], nsteps=800, tol=1e-8, display=true)\n    \"\"\"\n        Solve the HO problem with the given parameters.\n\n        Parameters\n        ----------\n\n        x0 : array of floats\n            Initial condition\n        nsteps : int\n            Number of steps in the discretization\n        ε : float\n            Regularization parameter\n        tol : float\n            Tolerance for the solver\n        display : bool\n            If true, display the results\n\n        Returns\n        -------\n        \n        sol : DirecttSol\n            The (direct) solution of the problem\n            \"\"\"\n\n    # Create JuMP model, using Ipopt as the solver\n    sys = Model(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => display ? 5 : 1))\n    set_optimizer_attribute(sys,\"tol\", tol)\n    set_optimizer_attribute(sys,\"constr_viol_tol\", tol)\n    set_optimizer_attribute(sys,\"max_iter\",1000)\n    \n    # Constants\n    N  = nsteps     # Grid size\n    \n    @variables(sys, begin\n                x1[1:N+1]    \n                x2[1:N+1]   \n        -1.0  ≤  λ[1:N+1]  ≤ 1.0\n        -1.0  ≤  u[1:N+1]  ≤ 1.0\n        0.0  ≤ Δt         ≤ 1.0 \n                v[1:N+1] \n        -1e1  ≤ xv[1:N+1]\n        -1e1  ≤ xu[1:N+1]\n    end)\n    \n    set_start_value(Δt, 20/N);\n    for i in 1:N+1\n        set_start_value(λ[i] , 1.0);\n        set_start_value(v[i] , 0.0);\n        set_start_value(xv[i], 0.0);\n        set_start_value(xu[i], 0.0);\n    end\n    \n    T = Δt*(N+1) ;\n    \n    # Objective\n    @objective(sys, Min, T + ε*xv[N+1] + xu[N+1])\n\n    # Boundary constraints\n    @constraints(sys, begin\n        con_xu0, xu[1]   == 0.0\n        con_xv0, xv[1]   == 0.0\n        con_x10, x1[1]   == x0[1] \n        con_x20, x2[1]   == x0[2] \n        con_x1f, x1[N+1] == 0.0 \n        con_x2f, x2[N+1] == -1e-5\n    end)\n\n    # Dynamics\n    @NLexpression(sys, dx1[j = 1:N+1], x2[j])\n    @NLexpression(sys, dx2[j = 1:N+1], fC(x2[j])*u[j] +fNC(x2[j])*λ[j] - x1[j])\n    @NLexpression(sys,  dλ[j = 1:N+1], fC(x2[j])*v[j])\n    @NLexpression(sys, dxv[j = 1:N+1], v[j]^2)\n    @NLexpression(sys, dxu[j = 1:N+1], fNC(x2[j])*u[j]^2)\n    \n    # Dynamics with Crank-Nicolson scheme\n    @NLconstraints(sys, begin\n        con_dx1[j=1:N], x1[j+1] == x1[j] + 0.5 * Δt * (dx1[j+1] + dx1[j])\n        con_dx2[j=1:N], x2[j+1] == x2[j] + 0.5 * Δt * (dx2[j+1] + dx2[j])\n        con_dx3[j=1:N],  λ[j+1] ==  λ[j] + 0.5 * Δt * (dλ[j+1]  + dλ[j])\n        con_dxv[j=1:N], xv[j+1] == xv[j] + 0.5 * Δt * (dxv[j+1] + dxv[j])\n        con_dxu[j=1:N], xu[j+1] == xu[j] + 0.5 * Δt * (dxu[j+1] + dxu[j])\n    end)\n    \n    \n    # Solve for the control and state\n    if display\n        println(\"Solving...\")\n    end\n    status = optimize!(sys)\n    if display\n        println()\n    end\n\n    # Display results\n    if display\n        if termination_status(sys) == MOI.OPTIMAL\n            println(\"  Solution is optimal\")\n        elseif  termination_status(sys) == MOI.LOCALLY_SOLVED\n            println(\"  (Local) solution found\")\n        elseif termination_status(sys) == MOI.TIME_LIMIT && has_values(sys)\n            println(\"  Solution is suboptimal due to a time limit, but a primal solution is available\")\n        else\n            error(\"  The model was not solved correctly.\")\n        end\n        println(\"  objective value = \", objective_value(sys))\n        println()\n    end\n\n    # Retrieves values (including duals)\n    x1 = value.(x1)[:]\n    x2 = value.(x2)[:]\n    λ  = value.(λ)[:]\n    u  = value.(u)[:]\n    v  = value.(v)[:]\n    xu  = value.(xu)[:]\n    xv  = value.(xv)[:]\n    t  = (0:N) * value.(Δt)\n    \n    \n    px10 = - dual(con_x10)\n    px20 = - dual(con_x20)\n    px1f =   dual(con_x1f)                                 \n    px2f =   dual(con_x2f) \n    \n    px30 = 0 # λ(0) is free\n    px3f = 0 # λ(T) is free\n\n\n    # duals of the dynamics\n    px1 = -[ dual(con_dx1[i]) for i in 1:N ]\n    px2 = -[ dual(con_dx2[i]) for i in 1:N ]\n    px3 = -[ dual(con_dx3[i]) for i in 1:N ]\n\n    # adjoint vectors\n    p1 = [px10; (px1[1:N-1]+px1[2:N])/2; px1f]\n    p2 = [px20; (px2[1:N-1]+px2[2:N])/2; px2f]\n    p3 = [px30; (px3[1:N-1]+px3[2:N])/2; px3f]\n    \n    \n    \n    return DirecttSol(t, x1, x2, λ, u, v, xu, xv, p1, p2, p3)\n     \nend","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# Resolution\nε   = 1e-3\nsol = HO(ε)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# Plots\nt  = sol.t\nx1 = sol.x1\nx2 = sol.x2\nλ  = sol.λ\nu  = sol.u\nv  = sol.v\nxu = sol.xu\nxv = sol.xv\np1 = sol.p1\np2 = sol.p2\np3 = sol.p3\n\nprintln(\"xu = \", xu[end])\nprintln(\"xv = \", xv[end])\n\n# Compute the differences between adjacent elements\nd = diff(u)\n\nswitchings = findall(abs.(x2) .< 0.012)\ntc1   = t[switchings[1]]\ntc2   = t[switchings[2]]\ntc3   = t[switchings[3]]\ntstar = t[findall(abs.(d) .> 1.5)[]]\n\nT  = t[end]\n\nx1_plot   = plot(t,  x1, xlabel = \"t\", ylabel = \"x1\",   legend=false,  linecolor=:blue , linewidth=2)\nx2_plot   = plot(t,  x2, xlabel = \"t\", ylabel = \"x2\",    legend=false,  linecolor=:blue , linewidth=2)\nxticks!(x2_plot, [tc1,2.,tc2,tc3,8.], [L\"$\\tau_1$\",\"2\",L\"$\\tau_2$\",L\"$\\tau_3$\", \"8\"])\nvline!(x2_plot, [tc1], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(x2_plot, [tc2], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(x2_plot, [tc3], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nhline!([(0., 0), (31., 0)], linecolor=:black, linewidth=2, label=false)\n\nu1 = copy(u)\n\nu1[tc1  .<= t .<= tc2] .= λ[(switchings[1] + switchings[2]) ÷ 2]\nu1[tc3 .<= t .<=   T] .= λ[(switchings[4] + length(t)) ÷ 2]\n\ncontrol_plot = plot(t, u1,  xlabel = \"t\", label=L\"optimal control $u$\",linecolor=:red ,linewidth=2,legend=:bottomleft) \nplot!(t, λ, xlabel = \"t\", ylabel = \"(λ,u)\",  label =L\"state $\\lambda$\", linecolor=:brown,linewidth=2)\nxticks!(control_plot, [tc1,2.,tc2,tstar,tc3,8.], [L\"$\\tau_1$\",\"2\",L\"$\\tau_2$\",L\"$\\sigma$\",L\"$\\tau_3$\", \"8\"])\nvline!(control_plot, [tc1], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(control_plot, [tc2], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(control_plot, [tc3], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(control_plot, [tstar], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\n\nx1x2_plot = plot(x1, x2, xlabel = \"x1\", ylabel = \"x2\",  legend=false,  linecolor=:blue , linewidth=2)\nplot!(x1x2_plot, [-3, 5], [-4.0, -4.0], fillrange = 0.0, fillalpha = 0.2, fillcolor = :red, label=false)\nplot!(x1x2_plot, [-3, 5], [4.3, 4.3], fillrange = 0.0, fillalpha = 0.2, fillcolor = :green, label=false)\nplot!(x1x2_plot, [-3, 5], [0., 0.], linecolor=:black, linewidth=2, label=false)\n\nλ_plot = plot(t, λ, xlabel = \"x1\", ylabel = \"λ\",  legend = false)\n\np1_plot   = plot(t, p1, xlabel = \"t\", ylabel = \"p1\",  legend=false, linecolor=:orange , linewidth=2)\np2_plot   = plot(t, p2, xlabel = \"t\", ylabel = \"p2\",  legend=false, linecolor=:orange , linewidth=2)\nxticks!(p2_plot, [tc1,2,tc2,tstar,tc3,8], [L\"$\\tau_1$\",\"2\",L\"$\\tau_2$\",L\"$\\sigma$\",L\"$\\tau_3$\",\"8\"])\nvline!(p2_plot, [tc1], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(p2_plot, [tc2], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(p2_plot, [tc3], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(p2_plot, [tstar], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\n\nplot(x1x2_plot, x1_plot,x2_plot, control_plot , p1_plot,p2_plot, layout = (2,3), size=(900, 500), left_margin=5mm)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"function H(k)\n    return (p1[k] * x2[k]) + (p2[k] * (fC(x2[k])*u[k] +fNC(x2[k])*λ[k] - x1[k])) + p3[k]*fC(x2[k])*v[k] - ε * (v[k])^2 - fNC(x2[k]) * (u[k])^2\nend\nH_direct  = [H(k) for k in 1:length(x1)]\nph_plot   = plot(t, H_direct, xlabel = \"t\", ylabel = \"H_direct\",  legend=false, linecolor=:green , linewidth=2)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"jmp1 = -(p2[switchings[1]+3] - p2[switchings[1]-2]) \njmp3 = -(p2[switchings[3]+3] - p2[switchings[3]-2])  \nlambda = λ[(switchings[3] + length(t)) ÷ 2] \n\nprintln(\" p2(t1+) - p2(t1-) = \", jmp1)\nprintln(\" p2(t3+) - p2(t3-) = \", jmp3)\nprintln(\" lambda(t3+) = \", lambda)","category":"page"},{"location":"ho.html#Indirect-method","page":"Harmonic oscillator","title":"Indirect method","text":"","category":"section"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"using NLsolve\nusing Plots\nusing Plots.PlotMeasures\ninclude(\"flow.jl\");","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# Dynamics\nfunction F0(x)\n    return [ x[2], -x[1]]\nend\n\nfunction F1(x)\n    return [ 0.0 ,   1.0]\nend\n\nH0(x, p) = p' * F0(x) \nH1(x, p) = p' * F1(x)\n\n# Hamiltonians: \nH(x, p, u)  =  H0(x, p) + u*H1(x,p)                             # pseudo-Hamiltonian\n\nup(x, p) =   1.0\num(x, p) = - 1.0\n\nHp(x, p) = H(x, p, up(x, p))\nHm(x, p) = H(x, p, um(x, p))\n\n# Hamiltonians: control loss region 2\nH2(x, b, y, p)  = H0(x, p) + b*H1(x, p) - y*p[2]                # pseudo-Hamiltonian\nHcl(X, P)       = H2(X[1:2], X[3], X[4], P[1:2])                # control loss 2\n\n# Flows\nfp    = Flow(Hp)\nfm    = Flow(Hm)\nfcl   = Flow(Hcl)\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"t0 = 0.0\nx0 = [2.5; 4.0]\n\n# Shooting function\nfunction SHOOT(p0, tt1, tt2, ttstar, tt3, b1, jump1, jump2, TT) \n    \n    pb0    = 0.0 \n    py0    = 0.0\n        \n    x1, p1 = fm(t0 , x0, p0, tt1) \n    x2, p2 = fp(tt1, x1, p1 - [0. , jump1], tt2)\n    x3, p3 = fp(tt2, x2, p2, ttstar)\n    x4, p4 = fm(ttstar, x3, p3, tt3)\n    X5, P5 = fcl(tt3, [x4 ; b1 ; 0.0], [p4 - [0. , jump2]; pb0 ; py0], TT)\n\n    s = zeros(eltype(p0), 10)\n    \n    s[1:2]  = X5[1:2] - [ 0.0 , 0.0 ]                     # target\n    s[3]    = H1(x3, p3)                                  # switching\n    s[4]    = x1[2] - 0.0                                 # first crossing \n    s[5]    = x2[2] - 0.0                                 # second crossing \n    s[6]    = x4[2] - 0.0                                 # third crossing \n    s[7]    = jump1 - p1[2]*(1. + 1.)/(1. - x1[1])        # jump1\n    s[8]    = jump2 - p4[2]*(b1 + 1.)/(b1 - x4[1])        # jump2\n    s[9]    = Hm(x0, p0) - 1.0                            # free final time\n    s[10]   = P5[4]                                       # averaged gradient condition \n\n    return s\n\nend\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"S(ξ) = SHOOT(ξ[1:2], ξ[3], ξ[4], ξ[5],ξ[6],ξ[7],ξ[8], ξ[9], ξ[10]);\nξ_guess = [p1[1] , p2[1], tc1, tc2, tstar , tc3, lambda, jmp1, jmp3, t[end]]; # initial guess\nS(ξ_guess)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# Solve\nindirect_sol = nlsolve(S, ξ_guess; xtol=1e-8, method=:trust_region, show_trace=true)\nprintln(indirect_sol)\n\n# Retrieves solution\nif indirect_sol.f_converged || indirect_sol.x_converged\n    pp0     = indirect_sol.zero[1:2]\n    tt1     = indirect_sol.zero[3]\n    tt2     = indirect_sol.zero[4]\n    ttstar  = indirect_sol.zero[5]\n    tt3     = indirect_sol.zero[6]\n    b11     = indirect_sol.zero[7]\n    jmp1    = indirect_sol.zero[8]\n    jmp2    = indirect_sol.zero[9]\n    T1      = indirect_sol.zero[10]\nelse\n    error(\"Not converged\")\nend\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"t0 = 0.0\nx0 = [2.5; 4.0]\n\node_sol = fm((t0, tt1), x0, pp0, saveat=0.1) ;\nttt1    = ode_sol.t ;\nxx1     = [ ode_sol[1:2, j] for j in 1:size(ttt1, 1) ] ;\npp1     = [ ode_sol[3:4, j] for j in 1:size(ttt1, 1) ] ;\nuu1     = um.(xx1, pp1);\n\node_sol = fp((tt1, tt2), xx1[end], pp1[end] - [0., jmp1], saveat=0.1) ;\nttt2    = ode_sol.t ;\nxx2     = [ ode_sol[1:2, j] for j in 1:size(ttt2, 1) ] ;\npp2     = [ ode_sol[3:4, j] for j in 1:size(ttt2, 1) ] ;\nuu2     = up.(xx2, pp2)  ;\n\node_sol = fp((tt2, ttstar), xx2[end], pp2[end] , saveat=0.1) ;\nttt3    = ode_sol.t ;\nxx3     = [ ode_sol[1:2, j] for j in 1:size(ttt3, 1) ] ;\npp3     = [ ode_sol[3:4, j] for j in 1:size(ttt3, 1) ] ;\nuu3     = up.(xx3, pp3)  ;\n\node_sol = fm((ttstar, tt3), xx3[end], pp3[end], saveat=0.1) ;\nttt4    = ode_sol.t ;\nxx4     = [ ode_sol[1:2, j] for j in 1:size(ttt4, 1) ] ;\npp4     = [ ode_sol[3:4, j] for j in 1:size(ttt4, 1) ] ;\nuu4     = um.(xx4, pp4)  ;\n\node_sol = fcl((tt3, T1), [xx4[end] ; b11 ; 0.0], [pp4[end] - [0., jmp2]; 0. ; 0.], saveat=0.1)\nttt5    = ode_sol.t\nxx5     = [ ode_sol[1:2, j] for j in 1:size(ttt5, 1) ]\npp5     = [ ode_sol[5:6, j] for j in 1:size(ttt5, 1) ] \nuu5     = b11.*ones(length(ttt5))\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"t = [ ttt1 ; ttt2 ; ttt3 ; ttt4 ; ttt5 ]\nx = [ xx1 ; xx2 ; xx3 ; xx4 ; xx5 ]\np = [ pp1 ; pp2 ; pp3 ; pp4 ; pp5 ]\nu = [ uu1 ; uu2 ; uu3 ; uu4 ; uu5 ]\n\nm = length(t)\n\nx1 = [ x[i][1] for i=1:m ]\nx2 = [ x[i][2] for i=1:m ]\np1 = [ p[i][1] for i=1:m ]\np2 = [ p[i][2] for i=1:m ];\n\nx1_plot   = plot(t,  x1, xlabel = \"t\", ylabel = \"x1\" ,legend=false,  linecolor=:blue , linewidth=2)\nx2_plot   = plot(t,  x2, xlabel = \"t\", ylabel = \"x2\" ,legend=false,  linecolor=:blue , linewidth=2)\nxticks!(x2_plot, [ttt1[end],2,ttt2[end],ttt4[end],8], [L\"$\\tau_1^*$\",\"2\",L\"$\\tau_2^*$\",L\"$\\tau_3^*$\",\"8\"])\nvline!(x2_plot, [ttt1[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(x2_plot, [ttt2[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(x2_plot, [ttt4[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nhline!([(0., 0), (31., 0)], linecolor=:black, linewidth=2, label=false)\n\np1_plot   = plot(t,  p1,xlabel = \"t\", ylabel = \"p1\", legend=false, linecolor=:orange , linewidth=2)\np2_plot   = plot(t,  p2,xlabel = \"t\", ylabel = \"p2\", legend=false,  linecolor=:orange , linewidth=2)\nxticks!(p2_plot, [ttt1[end],2,ttt2[end],ttt3[end],ttt4[end],8], [L\"$\\tau_1^*$\",\"2\",L\"$\\tau_2^*$\",L\"$\\sigma^*$\",L\"$\\tau_3^*$\",\"8\"])\nvline!(p2_plot, [ttt1[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(p2_plot, [ttt2[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(p2_plot, [ttt4[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(p2_plot, [ttt3[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\n\nu_plot    = plot(t,   u,xlabel = \"t\", ylabel = \"u\", legend=false,  linecolor=:red , linewidth=2) #, linetype=:steppre)\nxticks!(u_plot, [ttt1[end],2,ttt2[end],ttt3[end],ttt4[end],8], [L\"$\\tau_1^*$\",\"2\",L\"$\\tau_2^*$\",L\"$\\sigma^*$\",L\"$\\tau_3^*$\",\"8\"])\nvline!(u_plot, [ttt1[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(u_plot, [ttt2[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(u_plot, [ttt3[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\nvline!(u_plot, [ttt4[end]], linestyle=:dash, linecolor=RGBA(0.5, 0.5, 0.5, 0.5), label=nothing)\n\nx1x2_plot = plot(x1, x2, xlabel = \"x1\", ylabel = \"x2\",legend=false,  linecolor=:blue , linewidth=2)\nplot!(x1x2_plot, [-3, 5], [-4.0, -4.0], fillrange = 0.0, fillalpha = 0.2, fillcolor = :red, label=false)\nplot!(x1x2_plot, [-3, 5], [4.3, 4.3], fillrange = 0.0, fillalpha = 0.2, fillcolor = :green, label=false)\nplot!(x1x2_plot, [-3, 5], [0., 0.], linecolor=:black, linewidth=2, label=false)\n\nx=plot(x1x2_plot, x1_plot,x2_plot, u_plot , p1_plot,p2_plot, layout = (2,3), size=(900, 500), left_margin=5mm)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"function trapezoidal_integral(p, tt)\n    integral = 0.0\n    for i in 1:(length(tt) - 1)\n        integral += (p[i] + p[i + 1]) * (tt[i + 1] - tt[i]) / 2\n    end\n    return integral\nend\np2NC = [v[2] for v in pp2]\ntrapezoidal_integral(p2NC, ttt2)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# create an animation\nanimx = @animate for i = 1:length(t)\n    plot(x1[1:i], x2[1:i], xlim=(-3.,5.), ylim=(-4.,4.3), xlabel=\"x1\", ylabel=\"x2\", label=\"optimal trajectory \\$x\\$\", linecolor=:blue,  linewidth=2)\n    scatter!([x1[i]], [x2[i]], markersize=4, marker=:circle, color=:black, label=false)\n    plot!( [-3, 5], [-4.0, -4.0], fillrange = 0.0, fillalpha = 0.2, fillcolor = :red, label=false)\n    plot!( [-3, 5], [4.3, 4.3], fillrange = 0.0, fillalpha = 0.2, fillcolor = :green, label=false)\n    plot!( [-3, 5], [0., 0.], linecolor=:black, linewidth=2, label=false)\n    \nend\n\n# create an animation\nanimu = @animate for i = 1:length(t)\n    plot(t[1:i], u[1:i], xlim=(0.,t[end]), ylim=(-1.2,1.2), xlabel=\"t\", ylabel=\"u\", label=\"opitmal control \\$u\\$\", linecolor=:red,  linewidth=2)\nend\n\n# create an animation\nanimp1 = @animate for i = 1:length(t)\n    plot(t[1:i], p1[1:i], xlim=(0.,t[end]), ylim=(-1.3, 0.5), xlabel=\"t\", ylabel=\"p1\", label=\"adjoint vector \\$p1\\$\", linecolor=:orange,  linewidth=2)\nend\n\n# create an animation\nanimp2 = @animate for i = 1:length(t)\n    plot(t[1:i], p2[1:i], xlim=(0.,t[end]), ylim=(-1.5,1.3), xlabel=\"t\", ylabel=\"p2\", label=\"adjoint vector \\$p2\\$\", linecolor=:orange,  linewidth=2)\nend\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# display the animation\ngif(animx, \"ho_x.gif\", fps = 10)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# display the animation\ngif(animu, \"ho_u.gif\", fps = 10)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# display the animation\ngif(animp1, \"ho_p1.gif\", fps = 10)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator","title":"Harmonic oscillator","text":"# display the animation\ngif(animp2, \"ho_p2.gif\", fps = 10)","category":"page"},{"location":"zermelo2.html#Zermelo-problem,-example-2","page":"Zermelo example 2","title":"Zermelo problem, example 2","text":"","category":"section"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"We consider the Zermelo-type optimal control problem with loss control regions given by","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"    beginequation\n    beginarraylcl\n        textminimize  -x_1(8)10pt\n        textsubject to   (xu) in mathrmAC(08mathbbR^2) times mathrmL^infty(08mathbbR) 6pt\n          dotx_1(t) = x_2(t) + cos(u(t)) quad textae  tin 08 6pt\n          dotx_2(t) = sin(u(t)) quad textae  tin 08 6pt\n           x(0)=0_mathbbR^2 quad x_2(8)=4  6pt\n           u(t) in left-fracpi2fracpi2right quad textae  tin 08 6pt\n           u text is constant when  x text is in the loss control regions  x in mathbbR^2 mid 5  x_1  10  text and  x in mathbbR^2 mid 20  x_1  25 \n    endarray\n    endequation","category":"page"},{"location":"zermelo2.html#Reformulation-for-the-direct-method","page":"Zermelo example 2","title":"Reformulation for the direct method","text":"","category":"section"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"    left\n    beginarrayl\n        displaystyle min - x_1(8) + varepsilonint_0^8 v^2(t)dt + int_0^1 f_NC(x(t))u^2(t)dt 05em\n        dotx_1(t) = f_C(x(t))(x_2(t) + cos(u(t))) + f_NC(x_2(t) + cos(lambda(t)))  textfor ae  tin 0805em\n        dotx_2(t) = f_C(x(t))sin(u(t)) + f_NC(x(t))sin(lambda(t))   textfor ae  tin 08 05em\n        dotlambda(t) = f_C(x(t))v^2(t)   textfor ae  tin 08 05em\n\n        u(t) in -fracpi2 fracpi2  textfor ae  tin 08 05em\n        x(0) = 0_mathbbR^2 quad x_2(8) = 405em\n        x in mathbbR^2 mid 5  x_1  10  text and  x in mathbbR^2 mid 20  x_1  25 \n        text are the loss control regions\n    endarray\n    right","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"using JuMP  \nusing Ipopt\nusing Plots\nusing Plots.PlotMeasures\nusing LaTeXStrings","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"mutable struct DirecTSS\n    t; x1; x2 ; λ ; u ; xu ; xv ; p1 ; p2\nend\n\nmutable struct DirecttSol\n    t; x1; x2 ; λ ; u ; v ; xu ; xv ; p1 ; p2 ; p3\nend","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"distance_squared(x, a, b) = x < a ? (a - x)^2 : x > b ? (x - b)^2 : 0 ;\n\n#Moreau Yosida regularization\n\nfunction MY_reg(x, a, b, k)\n    return 1 - exp(-k*distance_squared(x, a, b))\nend\n\nfC(x)  = MY_reg(x, 2, 16, 300) + MY_reg(x, 20, 25, 300) - 1\nfNC(x) = 1- fC(x)\nplot(fNC, -10, 40)","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"function ZERMELO(ε=1e-3; x0=[0, 0], nsteps=1000, tol=1e-10, display=true)\n    \"\"\"\n        Solve the Zermelo problem with the given parameters.\n\n        Parameters\n        ----------\n\n        x0 : array of floats\n            Initial condition\n        nsteps : int\n            Number of steps in the discretization\n        ε : float\n            Regularization parameter\n        tol : float\n            Tolerance for the solver\n        display : bool\n            If true, display the results\n\n        Returns\n        -------\n        \n        sol : DirecttSol\n            The (direct) solution of the problem\n\n    \"\"\"\n\n    # Create JuMP model, using Ipopt as the solver\n    sys = Model(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => display ? 5 : 1))\n    set_optimizer_attribute(sys,\"tol\", tol)\n    set_optimizer_attribute(sys,\"constr_viol_tol\", tol)\n    set_optimizer_attribute(sys,\"max_iter\", 200)\n    \n    # Constants\n    N  = nsteps     # Grid size\n    \n    # Variables\n    @variables(sys, begin\n        x1[1:N+1]\n        x2[1:N+1]\n        -2  ≤  λ[1:N+1]  ≤ 2 # we add box constraints to help the convergence\n        -2  ≤  u[1:N+1]  ≤ 2\n        v[1:N+1]\n        xv[1:N+1]\n        xu[1:N+1]\n    end)\n    \n    # Objective\n    @NLobjective(sys, Min, -x1[N+1] + ε*xv[N+1] + xu[N+1])\n    \n    # Boundary constraints\n    @constraints(sys, begin\n        con_xu0, xu[1]   == 0\n        con_xv0, xv[1]   == 0\n        con_x10, x1[1]   == x0[1]\n        con_x20, x2[1]   == x0[2]\n        con_x2f, x2[N+1] == 4\n        end)\n    \n    # Expressions for the dynamics\n    @NLexpression(sys, dx1[j = 1:N+1], x2[j] + fNC(x1[j])*cos(λ[j]) + fC(x1[j])*cos(u[j]))\n    @NLexpression(sys, dx2[j = 1:N+1],         fNC(x1[j])*sin(λ[j]) + fC(x1[j])*sin(u[j]) )\n    @NLexpression(sys,  dλ[j = 1:N+1], fC(x1[j])*v[j])\n    @NLexpression(sys, dxv[j = 1:N+1], v[j]^2)\n    @NLexpression(sys, dxu[j = 1:N+1], fNC(x1[j])*u[j]^2)\n    \n    # Dynamics with Crank-Nicolson scheme\n    Δt = 8/(N+1)\n    @NLconstraints(sys, begin\n        con_dx1[j=1:N], x1[j+1] == x1[j] + 0.5 * Δt * (dx1[j+1] + dx1[j])\n        con_dx2[j=1:N], x2[j+1] == x2[j] + 0.5 * Δt * (dx2[j+1] + dx2[j])\n        con_dx3[j=1:N],  λ[j+1] ==  λ[j] + 0.5 * Δt * (dλ[j+1]  + dλ[j])\n        con_dxv[j=1:N], xv[j+1] == xv[j] + 0.5 * Δt * (dxv[j+1] + dxv[j])\n        con_dxu[j=1:N], xu[j+1] == xu[j] + 0.5 * Δt * (dxu[j+1] + dxu[j])\n    end);\n    \n    if display\n        println(\"Solving...\")\n    end\n    status = optimize!(sys)\n    if display\n        println()\n    end\n        \n    # Display results\n    if display\n        if termination_status(sys) == MOI.OPTIMAL\n            println(\"  Solution is optimal\")\n        elseif  termination_status(sys) == MOI.LOCALLY_SOLVED\n            println(\"  (Local) solution found\")\n        elseif termination_status(sys) == MOI.TIME_LIMIT && has_values(sys)\n            println(\"  Solution is suboptimal due to a time limit, but a primal solution is available\")\n        else\n            error(\"  The model was not solved correctly.\")\n        end\n        println(\"  objective value = \", objective_value(sys))\n        println()\n    end    \n        \n    # Retrieves values (including duals)\n    x1 = value.(x1)[:]\n    x2 = value.(x2)[:]\n    λ  = value.(λ)[:]\n    u  = value.(u)[:]\n    v  = value.(v)[:]\n    xu  = value.(xu)[:]\n    xv  = value.(xv)[:]\n    t  = (0:N) * value.(Δt)\n    \n    # duals of the boundary constraints\n    px10 = -dual(con_x10)\n    px20 = -dual(con_x20)\n    px30 = 0 # λ(0) is free\n    px1f = 1\n    px2f = dual(con_x2f) \n    px3f = 0 # λ(4) is free\n\n    # duals of the dynamics\n    px1 = -[ dual(con_dx1[i]) for i in 1:N ]\n    px2 = -[ dual(con_dx2[i]) for i in 1:N ]\n    px3 = -[ dual(con_dx3[i]) for i in 1:N ]\n\n    # adjoint vectors\n    p1 = [px10; (px1[1:N-1]+px1[2:N])/2; px1f]\n    p2 = [px20; (px2[1:N-1]+px2[2:N])/2; px2f]\n    p3 = [px30; (px3[1:N-1]+px3[2:N])/2; px3f]\n\n    return DirecttSol(t, x1, x2, λ, u, v, xu, xv, p1, p2, p3)\n        \nend;","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# Resolution\nε   = 1e-3\nsol_direct = ZERMELO(ε);","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# Plots\n\nt  = sol_direct.t\nx1 = sol_direct.x1\nx2 = sol_direct.x2\nu  = sol_direct.u\nv  = sol_direct.v\nxu = sol_direct.xu\nxv = sol_direct.xv\nλ  = sol_direct.λ\np1  = sol_direct.p1\np2  = sol_direct.p2\np3  = sol_direct.p3\n\nprintln(\"xu = \", xu[end])\nprintln(\"xv = \", xv[end])\n\nindex1 = findfirst(abs.(x1.-  2.)  .<= 0.02)\nindex2 = findfirst(abs.(x1.- 16.)  .<= 0.04)\nindex3 = findfirst(abs.(x1.- 20.)  .<= 0.05)\nindex4 = findfirst(abs.(x1.- 25.)  .<= 0.06)\n\nt1 = t[index1]\nt2 = t[index2]\nt3 = t[index3]\nt4 = t[index4]\n\nu1   = deepcopy(u)\nu1[t1  .<= t .<= t2] .= λ[div(index1 + index2, 2)]\nu1[t3  .<= t .<= t4] .= λ[div(index3 + index4, 2)]\n\n# plots\nx1_plot   = plot(t, x1, label=\"x₁(t)\", linecolor=:blue, linewidth=2)\nxticks!(x1_plot, [2.,t1,t2,t3,t4,8.], [\"2\",L\"$\\tau_1$\",L\"$\\tau_2$\",L\"$\\tau_3$\",L\"$\\tau_4$\",\"8\"])\nvline!(x1_plot, [t1], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(x1_plot, [t2], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(x1_plot, [t3], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(x1_plot, [t4], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nhline!([(0., 5), (31., 5)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 10), (31., 10)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 20), (31., 20)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 25), (31., 25)], linecolor=:black, linewidth=2, label=false)\n\nx2_plot   = plot(t,  x2, label=\"x₂(t)\", linecolor=:blue, linewidth=2)\n\np1_plot   = plot(t, p1, label=\"p₁(t)\", linecolor=:orange, linewidth=2, ylims=(0.9, 1.3))\nvline!(p1_plot, [t1], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p1_plot, [t2], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p1_plot, [t3], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p1_plot, [t4], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\np2_plot   = plot(t,  p2, label=\"p₂(t)\", linecolor=:orange, linewidth=2)\n\nu_plot = plot(t,  u, label=\"u(t)\" ,linecolor=:red ,linewidth=2, ylims=(-1.5, 1.5))\nplot!(t, λ, label=\"λ(t)\", linecolor=:brown , linewidth=2)\nxticks!(u_plot, [2.,t1,t2,t3,t4,8.], [\"2\",L\"$\\tau_1$\",L\"$\\tau_2$\",L\"$\\tau_3$\",L\"$\\tau_4$\",\"8\"])\nvline!(u_plot, [t1], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [t2], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [t3], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [t4], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\nx1x2_plot = plot(x1, x2, xlabel = \"x₁\", ylabel = \"x₂\",   legend=false, linecolor=:blue, linewidth=2)\nplot!(x1x2_plot, [0.0, 5.],  [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\nplot!(x1x2_plot, [5., 10.],  [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :red, label=false)\nplot!(x1x2_plot, [10., 20.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\nplot!(x1x2_plot, [20., 25.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :red, label=false)\nplot!(x1x2_plot, [25., 32.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\nvline!([5., 10., 20., 25.], linecolor=:black, linewidth=2, label=false)\nylims!(0, 6)\n\nplot(x1x2_plot, x1_plot, x2_plot, u_plot, p1_plot, p2_plot , layout = (2,3), size=(900, 600))","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"v_plot   = plot(t,  v, label = \"v(t)\", linecolor=:purple, linewidth=2, ylims=(-1.2, 0.5))\nxticks!(v_plot, [2.,t1,t2,t3,t4,8.], [\"2\",L\"$\\tau_1$\",L\"$\\tau_2$\",L\"$\\tau_3$\",L\"$\\tau_4$\",\"8\"])\nvline!(v_plot, [t1], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(v_plot, [t2], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(v_plot, [t3], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(v_plot, [t4], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\n\np3_plot   = plot(t,  p3, label = \"pλ(t)\", linecolor=:orange, linewidth=2, ylims=(-0.1, 0.04))\nxticks!(p3_plot, [2.,t1,t2,t3,t4,8.], [\"2\",L\"$\\tau_1$\",L\"$\\tau_2$\",L\"$\\tau_3$\",L\"$\\tau_4$\",\"8\"])\nvline!(p3_plot, [t1], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(p3_plot, [t2], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(p3_plot, [t3], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\nvline!(p3_plot, [t4], linestyle=:dash, linecolor=:black, label=nothing, z_order=:back)\n\nplot(v_plot, p3_plot, p1_plot, p2_plot, layout = (2,2), size=(900, 600)) #, left_margin=10mm)","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"function H(k)\n    return p1[k] * x2[k] + p1[k] * (fNC(x1[k])*cos(λ[k]) + fC(x1[k])*cos(u[k])) +\n                        p2[k] * (fNC(x1[k])*sin(λ[k]) + fC(x1[k])*sin(u[k])) +\n                        p3[k] * fC(x1[k]) * v[k] -\n                        ε * v[k]^2 - fNC(x1[k]) * u[k]^2\nend\n\nH_direct  = [H(k) for k in 1:length(x1)]\nph_plot   = plot(t, H_direct, label = \"H(t): direct\", linecolor=:green , linewidth=2, ylims=(5.5, 7))","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"jmp1 = -(p1[div(index1 + index2, 2)] - p1[div(index1 + 1, 2)])\njmp2 = -(p1[div(index2 + index3, 2)] - p1[div(index1 + index2, 2)])\njmp3 = -(p1[div(index3 + index4, 2)] - p1[div(index2 + index3, 2)])\njmp4 = -(p1[div(index4 + length(t), 2)] - p1[div(index3 + index4, 2)])\n\nprintln(\" p1(t1+) - p1(t1-) = \", jmp1)\nprintln(\" p1(t2+) - p1(t2-) = \", jmp2)\nprintln(\" p1(t3+) - p1(t3-) = \", jmp3)\nprintln(\" p1(t4+) - p1(t4-) = \", jmp4)","category":"page"},{"location":"zermelo2.html#Indirect-method","page":"Zermelo example 2","title":"Indirect method","text":"","category":"section"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"using NLsolve\nusing Animations\nusing Reel\nusing Plots\nusing Plots.PlotMeasures\nusing LinearAlgebra\ninclude(\"flow.jl\");","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# Dynamics\nfunction F(x, u)\n    return [ x[2] + cos(u), sin(u) ]\nend\n\nfunction G(λ)\n    return [  sin(λ), -cos(λ) ]\nend\n\n# Hamiltonian: permanent region\nH1(x, u, p)  = p' * F(x, u)                               # pseudo-Hamiltonian\nu11(x, p)    = atan(p[2]/p[1])                            # maximizing control\nHc(x, p)     = H1(x, u11(x, p) , p )                      # Hamiltonian\n\n# Flow\nfc  = Flow(Hc)\n\n# Hamiltonian: control loss region\nH2(x, λ, y, p)   = p' * F(x, λ)   + y* p' *G(λ) # pseudo-Hamiltonian\nHcl(X, P)     = H2(X[1:2], X[3], X[4], P[1:2])  # Hamiltonian\n\n# Flow\nfcl  = Flow(Hcl);","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# parameters\nt0  = 0\ntf  = 8\nx2f = 4\nx0  = [0, 0]\n\n# Shooting function\nfunction shoot(p0, tt1, tt2, tt3, tt4, λ1, λ3, j1, j2, j3, j4) \n    \n    pλ0    = 0\n    py0    = 0\n    \n    x1, p1 =  fc(t0, x0, p0, tt1)\n    X2, P2 = fcl(tt1, [x1; λ1; 0], [p1 - [j1 , 0]; pλ0 ; py0], tt2) \n    x3, p3 =  fc(tt2, X2[1:2], P2[1:2] - [j2 , 0], tt3)\n    X4, P4 = fcl(tt3, [x3; λ3; 0], [p3 - [j3 , 0]; pλ0 ; py0], tt4)\n    xf, pf =  fc(tt4, X4[1:2], P4[1:2] - [j4 , 0], tf)\n\n    s = zeros(eltype(p0), 12)\n    s[1]  = xf[2] - x2f   # target\n    s[2]  = pf[1] - 1     # transversality condition\n    s[3]  = x1[1] - 2     # first crossing \n    s[4]  = X2[1] - 16    # second crossing \n    s[5]  = x3[1] - 20    # first crossing \n    s[6]  = X4[1] - 25    # second crossing \n    s[7]  = P2[4]         # averaged gradient condition1\n    s[8]  = P4[4]         # averaged gradient condition2\n\n    u_temp = u11(x1, p1)\n    s[9]  = j1 - (p1[1]*(cos(λ1) - cos(u_temp)) + \n                p1[2]*(sin(λ1) - sin(u_temp)))/(x1[2] + cos(λ1))    # jump 1\n\n    u_temp = u11(X2[1:2], P2[1:2])\n    s[10] = j2 - (P2[1]*(cos(u_temp) - cos(λ1)) + \n                P2[2]*(sin(u_temp) - sin(λ1)))/(X2[2]+cos(u_temp))  # jump 2\n\n    u_temp = u11(x3, p3)\n    s[11] = j3 - (p3[1]*(cos(λ3) - cos(u_temp)) + \n                p3[2]*(sin(λ3) - sin(u_temp)))/(x3[2] + cos(λ3))    # jump 3\n                \n    u_temp = u11(X4[1:2], P4[1:2])\n    s[12] = j4 - (P4[1]*(cos(u_temp) - cos(λ3)) + \n                P4[2]*(sin(u_temp) - sin(λ3)))/(X4[2]+cos(u_temp))  # jump 4\n\n    return s\n\nend;\n","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# Solve\n\nS(ξ)    = shoot(ξ[1:2], ξ[3], ξ[4], ξ[5], ξ[6], ξ[7], ξ[8], ξ[9], ξ[10], ξ[11], ξ[12]) ;\nξ_guess = [p1[1], p2[1], t1, t2,t3,t4, λ[div(index1+index2, 2)], λ[div(index3 + index4, 2)], jmp1, jmp2, jmp3, jmp4]; # initial guess\nprintln(\"Initial value of shooting:\\n\", S(ξ_guess), \"\\n\\n\") ;\n\nindirect_sol = nlsolve(S, ξ_guess; xtol=1e-8, method=:trust_region, show_trace=true)\nprintln(indirect_sol)\n\n# Retrieves solution\nif indirect_sol.f_converged || indirect_sol.x_converged\n    pp0 = indirect_sol.zero[1:2]\n    tt1 = indirect_sol.zero[3]\n    tt2 = indirect_sol.zero[4]\n    tt3 = indirect_sol.zero[5]\n    tt4 = indirect_sol.zero[6]\n    a1  = indirect_sol.zero[7]\n    b1  = indirect_sol.zero[8]\n    j11 = indirect_sol.zero[9]\n    j22 = indirect_sol.zero[10]\n    j33 = indirect_sol.zero[11]\n    j44 = indirect_sol.zero[12]\n    \nelse\n    error(\"Not converged\")\nend;","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"Initial value of shooting: [-0.0030603188532318804, 0.0, -0.017350592822976685, -0.005140082023801895, 0.0006248671940944917, -0.015256195622630031, 0.014008033191363628, 0.004393427264007859, 0.007024378500931461, 0.0025898436876357622, -0.0009230531585132078, 0.0005774517548917599]","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"Iter     f(x) inf-norm    Step 2-norm  –––   –––––––   –––––––         0     1.735059e-02              NaN         1     1.574661e-04     2.736572e-02         2     2.861110e-09     7.222442e-05 Results of Nonlinear Solver Algorithm     * Algorithm: Trust-region with dogleg and autoscaling     * Starting Point: [1.0197988115735401, 6.189426909118297, 1.8221778221778222, 5.4585414585414584, 6.105894105894106, 6.945054945054945, 1.1639275354231233, -0.4915287705628049, -0.02432108825537127, 0.047288220458145735, -0.01262338370173488, 0.009455063072500547]     * Zero: [1.0112722919499118, 6.16654218773788, 1.8315586754159638, 5.459536646381439, 6.105719912512274, 6.947171979616726, 1.1645203848740207, -0.4891213971550329, -0.031233366806228707, 0.04478696385887632, -0.0114710409471598, 0.009189735844423754]     * Inf-norm of residuals: 0.000000     * Iterations: 2     * Convergence: true     * |x - x'| < 1.0e-08: false     * |f(x)| < 1.0e-08: true     * Function Calls (f): 3     * Jacobian Calls (df/dx): 3","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# jumps from direct solution\nprintln(\" jumps from direct solution\")\nprintln(\" p1(t1+) - p1(t1-) = \", jmp1)\nprintln(\" p1(t2+) - p1(t2-) = \", jmp2)\nprintln(\" p1(t3+) - p1(t3-) = \", jmp3)\nprintln(\" p1(t4+) - p1(t4-) = \", jmp4)\n\nprintln(\"\")\n\n# jumps from indirect solution\nprintln(\" jumps from indirect solution\")\nprintln(\" p1(t1+) - p1(t1-) = \", j11)\nprintln(\" p1(t2+) - p1(t2-) = \", j22)\nprintln(\" p1(t3+) - p1(t3-) = \", j33)\nprintln(\" p1(t4+) - p1(t4-) = \", j44)","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"#Plots\n\npa0 = 0 \npb0 = 0\npy0 = 0\npz0 = 0\n\node_sol = fc((t0, tt1), x0, pp0, saveat=0.1) ;\nttt1    = ode_sol.t ;\nxx1     = [ ode_sol[1:2, j] for j in 1:size(ttt1, 1) ] ;\npp1     = [ ode_sol[3:4, j] for j in 1:size(ttt1, 1) ] ;\nuu1     = u11.(xx1, pp1)  ;\n\n\n\node_sol = fcl((tt1, tt2), [xx1[end] ; a1 ; 0.0], [pp1[end] - [ j11, 0.]; pa0 ; py0], saveat=0.1)\nttt2    = ode_sol.t\nxx2     = [ ode_sol[1:2, j] for j in 1:size(ttt2, 1) ]\npp2     = [ ode_sol[5:6, j] for j in 1:size(ttt2, 1) ]\nuu2     = a1.*ones(length(ttt2)) ;\n\n\node_sol = fc((tt2, tt3), xx2[end],  pp2[end] - [j22, 0.], saveat=0.1)\nttt3    = ode_sol.t\nxx3     = [ ode_sol[1:2, j] for j in 1:size(ttt3, 1) ]\npp3     = [ ode_sol[3:4, j] for j in 1:size(ttt3, 1) ] \nuu3     = u11.(xx3, pp3)  ;\n\node_sol = fcl((tt3, tt4), [xx3[end] ; b1 ; 0.0], [pp3[end] - [j33, 0.]; pb0 ; pz0], saveat=0.1)\nttt4    = ode_sol.t\nxx4     = [ ode_sol[1:2, j] for j in 1:size(ttt4, 1) ]\npp4     = [ ode_sol[5:6, j] for j in 1:size(ttt4, 1) ] \nuu4     = b1.*ones(length(ttt4)) ;\n\node_sol = fc((tt4, tf), xx4[end], pp4[end]- [j44, 0.], saveat=0.1)\nttt5 = ode_sol.t\nxx5 = [ ode_sol[1:2, j] for j in 1:size(ttt5, 1) ]\npp5 = [ ode_sol[3:4, j] for j in 1:size(ttt5, 1) ] \nuu5 = u11.(xx5, pp5)  ;\n\n\nt = [ ttt1 ; ttt2 ; ttt3 ; ttt4 ; ttt5]\nx = [ xx1 ; xx2 ; xx3 ; xx4 ; xx5 ]\np = [ pp1 ; pp2 ; pp3 ; pp4 ; pp5 ]\nu = [ uu1 ; uu2 ; uu3 ; uu4 ; uu5 ]\n\nm = length(t)\n\nx1 = [ x[i][1] for i=1:m ]\nx2 = [ x[i][2] for i=1:m ]\np1 = [ p[i][1] for i=1:m ]\np2 = [ p[i][2] for i=1:m ];\n\nx1_plot   = plot(t, x1, label=\"x₁(t)\", linecolor=:blue, linewidth=2)\nxticks!(x1_plot, [2.,ttt1[end],ttt2[end],ttt3[end],ttt4[end],8.], [\"2\", L\"$\\tau^*_1$\",L\"$\\tau^*_2$\",L\"$\\tau^*_3$\",L\"$\\tau^*_4$\",\"8\"])\nvline!(x1_plot, [ttt1[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(x1_plot, [ttt2[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(x1_plot, [ttt3[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(x1_plot, [ttt4[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nhline!([(0., 5), (31., 5)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 10), (31., 10)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 20), (31., 20)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 25), (31., 25)], linecolor=:black, linewidth=2, label=false)\n\nx2_plot   = plot(t,  x2, label=\"x₂(t)\", linecolor=:blue, linewidth=2)\n\np1_plot   = plot(t, p1, label=\"p₁(t)\", linecolor=:orange, linewidth=2, ylims=(0.8, 1.3))\nxticks!(p1_plot, [2.,ttt1[end],ttt2[end],ttt3[end],ttt4[end],8.], [\"2\",L\"$\\tau^*_1$\",L\"$\\tau^*_2$\",L\"$\\tau^*_3$\",L\"$\\tau^*_4$\",\"8\"])\nvline!(p1_plot, [ttt1[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p1_plot, [ttt2[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p1_plot, [ttt3[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(p1_plot, [ttt4[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\np2_plot   = plot(t,  p2, label=\"p₂(t)\", linecolor=:orange, linewidth=2)\n\nu_plot = plot(t,  u, label=\"u(t)\" ,linecolor=:red ,linewidth=2, ylims=(-1.5, 1.5))\nxticks!(u_plot, [2.,ttt1[end],ttt2[end],ttt3[end],ttt4[end],8.], [\"2\",L\"$\\tau^*_1$\",L\"$\\tau^*_2$\",L\"$\\tau^*_3$\",L\"$\\tau^*_4$\",\"8\"])\nvline!(u_plot, [ttt1[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [ttt2[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [ttt3[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\nvline!(u_plot, [ttt4[end]], linestyle=:dash, linecolor=:gray, label=nothing, z_order=:back)\n\nx1x2_plot = plot(x1, x2, xlabel = \"x₁\", ylabel = \"x₂\",   legend=false, linecolor=:blue, linewidth=2)\nplot!(x1x2_plot, [0.0, 5.],  [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\nplot!(x1x2_plot, [5., 10.],  [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :red, label=false)\nplot!(x1x2_plot, [10., 20.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\nplot!(x1x2_plot, [20., 25.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :red, label=false)\nplot!(x1x2_plot, [25., 31.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\nvline!([5., 10., 20., 25.], linecolor=:black, linewidth=2, label=false)\nylims!(0, 6)\n\nplot(x1x2_plot, x1_plot, x2_plot, u_plot, p1_plot, p2_plot , layout = (2,3), size=(900, 600))","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"function HH(k)\n    return p1[k] * (x2[k] + cos(u[k])) + p2[k] * sin(u[k])\nend\n\nH_indirect  = [HH(k) for k in 1:length(x2)]\nph_plot   = plot(t, H_indirect, label = \"H(t): indirect\", linecolor=:green , linewidth=2, ylims=(5.5, 7))","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# create an animation\nanimx = @animate for i = 1:length(t)\n    plot(x1[1:i], x2[1:i], xlim=(0.,31.), ylim=(-0.,5.5), xlabel=\"x1\", ylabel=\"x2\", label=\"optimal trajectory \\$x\\$\", linecolor=:blue,  linewidth=2)\n    scatter!([x1[i]], [x2[i]], markersize=4, marker=:circle, color=:black, label=false)\n    vline!([5., 10., 20., 25.], linecolor=:black, linewidth=2, label=false)\n    plot!( [0.0, 5.],  [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\n    plot!( [5., 10.],  [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :red, label=false)\n    plot!( [10., 20.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\n    plot!( [20., 25.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :red, label=false)\n    plot!( [25., 31.], [0.0, 0.0], fillrange = 6, fillalpha = 0.2, fillcolor = :green, label=false)\nend\n\n# create an animation\nanimu = @animate for i = 1:length(t)\n    plot(t[1:i], u[1:i], xlim=(0.,8.), ylim=(-pi/2,pi/2), xlabel=\"t\", ylabel=\"u\", label=\"opitmal control \\$u\\$\", linecolor=:red,  linewidth=2)\nend ;\n\n# create an animation\nanimp1 = @animate for i = 1:length(t)\n    plot(t[1:i], p1[1:i], xlim=(0.,8.), ylim=(0, 1.5), xlabel=\"t\", ylabel=\"p1\", label=\"adjoint vector \\$p1\\$\", linecolor=:orange,  linewidth=2)\nend ;\n\n# create an animation\nanimp2 = @animate for i = 1:length(t)\n    plot(t[1:i], p2[1:i], xlim=(0.,8.), ylim=(-3.,6.3), xlabel=\"t\", ylabel=\"p2\", label=\"adjoint vector \\$p2\\$\", linecolor=:orange,  linewidth=2)\nend ;","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# display the animation\ngif(animx, \"zer2_x.gif\", fps = 10)","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"gif(animu, \"zer2_u.gif\", fps = 10)","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# display the animation\ngif(animp1, \"zer2_p1.gif\", fps = 10)","category":"page"},{"location":"zermelo2.html","page":"Zermelo example 2","title":"Zermelo example 2","text":"# display the animation\ngif(animp2, \"zer2_p2.gif\", fps = 10)","category":"page"},{"location":"index.html#Loss-control-regions-in-optimal-control-problems","page":"Introduction","title":"Loss control regions in optimal control problems","text":"","category":"section"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"General context. Optimal control theory studies controlled systems to achieve desired targets with minimal cost. The Pontryagin maximum principle (PMP) provides necessary conditions for optimality, ensuring an adjoint vector (or costate) meets the Hamiltonian maximization condition.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Typically, optimal control involves permanent control, allowing modification of the control function at each time instant. However, practical constraints can lead to nonpermanent control. For instance, digital controls result in sampled-data control with discrete changes. In aerospace, eclipse constraints limit control for solar-powered satellites in a shadow region where the control is reduced to zero. Hence, it is desirable to keep the system outside these regions.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: aerospace) ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"    beginequation\n    beginaligned\n    textminimize  -x_1(8) 10pt\n    textsubject to  (xu) in mathrmAC(08mathbbR^2) times mathrmL^infty(08mathbbR) 6pt\n      dotx_1(t) = x_2(t) + cos(u(t)) quad textae  t in 08 6pt\n      dotx_2(t) = sin(u(t)) quad textae  t in 08 6pt\n      x(0)=0_mathbbR^2 quad x_2(8)=4 6pt\n      u(t) in left-fracpi2fracpi2right quad textae  t in 08 6pt\n      u text is constant when  x text is in the loss control region  x in mathbbR^2 mid 05  x_2  35 \n    endaligned\n    endequation","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Objective and approach. Here, we address optimal control problems with loss control regions[1], where the state space is divided into control regions and loss control regions. In control regions, control can change at any time, while in loss control regions, control must remain constant, though its value is to be optimized and can vary with each visit.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We extend our previous work by using a permanent control for control regions and a regionally switching parameter for loss control regions. This leads to a discontinuous dynamics framework, fitting into spatially hybrid optimal control theory. The hybrid maximum principle (HMP) extends the PMP to hybrid settings, with a piecewise absolutely continuous adjoint vector.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Numerical contribution. In this note we illustrate a two-step numerical method for optimal control problems with loss control regions. First, a direct numerical approach is applied to a regularized problem to manage discontinuities and outline the optimal trajectory's structure. Second, this helps initialize an indirect numerical method for the original problem, using the PMP from Theorem~1. The method incorporates the averaged Hamiltonian gradient condition and adjoint vector discontinuities to define an appropriate shooting function, adding to classical terms for non-hybrid optimal control problems (see ref).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Contents\nProvide a statement of the PMP with loss control regions.\nProvide a direct method for solving optimal control problems with loss control regions (based on a regularization technique).\nProvide an indirect method (shooting method) for solving optimal control problems with loss control regions using the PMP with loss control regions.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: T. Bayen, A. Bouali, L. Bourdin & O. Cots, Loss control regions in optimal control problems, Journal of Differential Equations, 12 (2024) 405, 359-397.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"}]
}
