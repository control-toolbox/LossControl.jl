var documenterSearchIndex = {"docs":
[{"location":"zermelo1.html#Zermelo-problem,-example-1","page":"Zermelo navigation problem: Example 1","title":"Zermelo problem, example 1","text":"","category":"section"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"    left\n    beginarrayl\n        displaystyle min - x_1(8) 05em\n        dotx_1(t) = x_2(t) + cos(u(t))  textfor ae  tin 0805em\n        dotx_2(t) = sin(u(t))   textfor ae  tin 08 05em\n        u(t) in -fracpi2 fracpi2  textfor ae  tin 08 05em\n        x(0) = 0_mathbbR^2 quad x_2(8) = 405em\n        x in mathbbR^2 mid 05  x_2  35  text is a loss control region\n    endarray\n    right","category":"page"},{"location":"zermelo1.html#Reformulation-for-the-direct-method","page":"Zermelo navigation problem: Example 1","title":"Reformulation for the direct method","text":"","category":"section"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"    left\n    beginarrayl\n        displaystyle min - x_1(8) + epsilonint_0^8 v^2(t)dt + int_0^1 f_NC(x(t))u^2(t)dt 05em\n        dotx_1(t) = f_C(x(t))(x_2(t) + cos(u(t))) + f_NC(x_2(t) + cos(lambda(t)))  textfor ae  tin 0805em\n        dotx_2(t) = f_C(x(t))sin(u(t)) + f_NC(x(t))sin(lambda(t))   textfor ae  tin 08 05em\n        dotlambda(t) = f_C(x(t))v^2(t)   textfor ae  tin 08 05em\n\n        u(t) in -fracpi2 fracpi2  textfor ae  tin 08 05em\n        x(0) = 0_mathbbR^2 quad x_2(8) = 405em\n        x in mathbbR^2 mid 05  x_2  35  text is a loss control region\n    endarray\n    right","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"using JuMP  \nusing Ipopt\nusing Plots\nusing Plots.PlotMeasures\nusing LaTeXStrings\nusing OptimalControl\nusing NLPModelsIpopt\ninclude(\"smooth.jl\")\nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"I1 = [(0.5, 3.5)]\nε1 = 0.01  \nfNC1(x) = fNC_bounded(x,I1,ε1)\nplot(fNC1,0., 5, label=\"fNC\")","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"@def ocp1 begin\n\n    ε   = 1e-3\n    tf  = 8\n\n\n    t ∈ [ 0., tf ],                  time\n\n    q = [ x1, x2, λ, xu, xv ] ∈ R^5, state\n\n    ω = [u, v] ∈ R^2,                control\n\n    #initial conditions\n    x1(0) == 0\n    x2(0) == 0\n    xu(0) == 0\n    xv(0) == 0\n\n    #final condition\n    x2(tf) == 4\n\n    #control constraint\n    -π/2  ≤  u(t)  ≤ π/2\n\n    #state constraints\n    -π/2  ≤  λ(t)  ≤ π/2\n\n    #hybrid control system\n     q̇(t) == [fNC1(x2(t))*(x2(t) + cos(λ(t))) + (1-fNC1(x2(t)))*(x2(t) + cos(u(t))),\n             fNC1(x2(t))*sin(λ(t)) +(1-fNC1(x2(t)))*sin(u(t)),\n             (1-fNC1(x2(t)))*v(t),\n             (v(t))^2,\n             fNC1(x2(t))*(u(t))^2]\n\n    #cost function        \n    -x1(tf) + ε*xv(tf) + xu(tf) → min    \nend\nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"N = 500\nsol1 = solve(ocp1; grid_size=N, print_level=4)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"plot(sol1; layout=:group, size=(800, 300))","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"tt1   = sol1.times\ntf    = 8\nx1(t) = sol1.state(t)[1]\nx2(t) = sol1.state(t)[2]\nλ(t)  = sol1.state(t)[3]\nu(t)  = sol1.control(t)[1]\np1(t) = sol1.costate(t)[1]\np2(t) = sol1.costate(t)[2]\na     = λ(tf) \nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"plot(x1, x2, 0, tf, label=\"optimal trajectory\", color=\"blue\", linewidth=2)\nplot!([0, 31], [0.5, 0.5], color=:black, label = false, linewidth=2)\nplot!([0, 31], [3.5, 3.5], color=:black, label = false, linewidth=2)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"plot(u, 0, tf, label=\"optimal control\", color=\"red\", linewidth=2)\nplot!(λ, 0, tf, label=\"state λ\", color=\"green\", linewidth=2)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"plot(p1,  0, tf, label=\"costate p1\", color=\"purple\", linewidth=2)\nplot!(p2, 0, tf, label=\"costate p2\", color=\"violet\", linewidth=2)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"# Find the first crossing time\nt1_index = findfirst(t -> x2(t) ≥ 0.5, tt1)\n\n# If t1 is found, find the next crossing time\nif t1_index !== nothing\n    t1       = tt1[t1_index]\n    t2_index = findfirst(t ->  x2(t) ≥ 3.5, tt1[t1_index+1:end])\n    t2_index = t2_index !== nothing ? t2_index + t1_index : nothing\n    t2 = t2_index !== nothing ? tt1[t2_index] : \"No such t2 found\"\nelse\n    t1 = \"No such t1 found\"\n    t2 = \"No such t2 found\"\nend\nprintln(\"first crossing time: \",  t1)\nprintln(\"second crossing time: \", t2)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"jmp1 = p2(t1+0.1)  - p2(t1-0.1)\njmp2 = p2(t2+0.1)  - p2(t2-0.1)\nprintln(\" p2(t1+) - p2(t1-) = \", jmp1)\nprintln(\" p2(t2+) - p2(t2-) = \", jmp2)","category":"page"},{"location":"zermelo1.html#Indirect-Method","page":"Zermelo navigation problem: Example 1","title":"Indirect Method","text":"","category":"section"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"using NonlinearSolve  \nusing OrdinaryDiffEq\nusing Animations","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"# Dynamics\nfunction F(x, u)\n    return [ x[2] + cos(u), sin(u) ]\nend\n\nfunction G(λ)\n    return [ sin(λ), - cos(λ) ]\nend\n\n# Hamiltonian: permanent region\nH1(x, u, p)  = p' * F(x, u)                 # pseudo-Hamiltonian\nu11(x, p)    = atan(p[2]/p[1])              # maximizing control\nHc(x, p)     = H1(x, u11(x, p) , p )        # Hamiltonian\n\n# Flow\nfc  = Flow(Hamiltonian(Hc))\n\n# Hamiltonian: control loss region\nH2(x, λ, y, p)   = p' * F(x, λ)   + y* p' *G(λ)    # pseudo-Hamiltonian\nHcl(X, P)        = H2(X[1:2], X[3], X[4], P[1:2])  # Hamiltonian\n\n# Flow\nfcl = Flow(Hamiltonian(Hcl))\nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"# parameters\nt0  = 0\ntf  = 8\nx2f = 4\nx0  = [0, 0]\nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"function shoot1(p0, tt1, tt2, λ, jump1, jump2) \n    \n    pλ0    = 0\n    py0    = 0\n    \n    x1, p1 = fc(t0, x0, p0, tt1)\n    X2, P2 = fcl(tt1, [x1; λ; 0], [p1 - [0, jump1]; pλ0; py0], tt2) # augmented flow\n    xf, pf = fc(tt2, X2[1:2], P2[1:2] - [0, jump2], tf)\n\n    s = zeros(eltype(p0), 7)\n    s[1]  = xf[2] - x2f # target\n    s[2]  = pf[1] - 1.0 # transversality condition\n    s[3]  = x1[2] - 0.5 # first crossing \n    s[4]  = X2[2] - 3.5 # second crossing \n    s[5]  = P2[4]       # averaged gradient condition\n    s[6]  = jump1 - (p1[1]*(cos(λ) - cos(u11(x1, p1)))           + \n                     p1[2]*(sin(λ) - sin(u11(x1, p1))))/(sin(λ))                                #jump 1\n    s[7]  = jump2 - (P2[1]*(cos(u11(X2[1:2], P2[1:2])) - cos(λ)) + \n                     P2[2]*(sin(u11(X2[1:2], P2[1:2])) - sin(λ)))/(sin(u11(X2[1:2], P2[1:2])))  #jump 2\n\n    return s\n\nend\nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"nle! =  (ξ, λ) -> shoot1(ξ[1:2], ξ[3], ξ[4], ξ[5], ξ[6], ξ[7])\nξ_guess = [p1(0), p2(0), t1, t2, a, jmp1, jmp2]            # initial guess\nprob = NonlinearProblem(nle!, ξ_guess)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"#solve\nindirect_sol1 = solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true))\n","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"# Retrieves solution\n    pp0   = indirect_sol1[1:2]\n    tt1   = indirect_sol1[3]\n    tt2   = indirect_sol1[4]\n    aa    = indirect_sol1[5]\n    jmp11 = indirect_sol1[6]\n    jmp22 = indirect_sol1[7]","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"# jumps from indirect solution\nprintln(\" jumps from indirect solution\")\nprintln(\" p2(t1+) - p2(t1-) = \", jmp11)\nprintln(\" p2(t2+) - p2(t2-) = \", jmp22)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"ode_sol = fc((t0, tt1), x0, pp0, saveat=0.1) \nttt1 = ode_sol.t \nxx1 = [ ode_sol[1:2, j] for j in 1:size(ttt1, 1) ] \npp1 = [ ode_sol[3:4, j] for j in 1:size(ttt1, 1) ] \nuu1 = u11.(xx1, pp1)  \n\npλ0 = 0. \npy0 = 0.\n\node_sol = fcl((tt1, tt2), [xx1[end] ; aa ; 0.0], [pp1[end] - [0. , jmp11]; pλ0 ; py0], saveat=0.1)\nttt2 = ode_sol.t\nxx2 = [ ode_sol[1:2, j] for j in 1:size(ttt2, 1) ]\npp2 = [ ode_sol[5:6, j] for j in 1:size(ttt2, 1) ]\nuu2 = a.*ones(length(ttt2)) ;\n\node_sol = fc((tt2, tf), xx2[end], pp2[end] - [0. , jmp22], saveat=0.1)\nttt3 = ode_sol.t\nxx3 = [ ode_sol[1:2, j] for j in 1:size(ttt3, 1) ]\npp3 = [ ode_sol[3:4, j] for j in 1:size(ttt3, 1) ] \nuu3 = u11.(xx3, pp3) \n\ntsol = [ ttt1 ; ttt2 ; ttt3 ]\nxsol = [ xx1 ; xx2 ; xx3 ]\npsol = [ pp1 ; pp2 ; pp3 ]\nusol = [ uu1 ; uu2 ; uu3 ]\n\nm = length(tsol)\n\nx11 = [ xsol[i][1] for i=1:m ]\nx22 = [ xsol[i][2] for i=1:m ]\np11 = [ psol[i][1] for i=1:m ]\np22 = [ psol[i][2] for i=1:m ]\nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"plot(x11, x22, label=\"optimal trajectory\", legend=false, linecolor=:blue, linewidth=2)\nhline!([(0., 0.5), (31., 0.5)], linecolor=:black, linewidth=2, label=false)\nhline!([(0., 3.5), (31., 3.5)], linecolor=:black, linewidth=2, label=false)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"plot(tsol,   usol, label=\"optimal control\" ,linecolor=:red ,linewidth=2)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"plot(tsol, p11, label=\"costate p1\", linecolor=:purple, linewidth=2)\nplot!(tsol,  p22, label=\"costate p2\", linecolor=:violet, linewidth=2)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"# create an animation\nanimx = @animate for i = 1:length(tsol)\n    plot(x11[1:i], x22[1:i],  xlim=(0.,31.), ylim=(-0.,5.5),  label=\"optimal trajectory\", linecolor=:blue,  linewidth=2)\n    scatter!([x11[i]], [x22[i]], markersize=4, marker=:circle, color=:black, label=false)\n    plot!([0, 31], [0.5, 0.5], color=:black, label=false, linewidth=2)\n    plot!([0, 31], [3.5, 3.5], color=:black, label=false, linewidth=2)\nend\n\nanimu = @animate for i = 1:length(tsol)\n    plot(tsol[1:i], usol[1:i], xlim=(0.,8.), ylim=(-pi/2,pi/2), label=\"opitmal control\", linecolor=:red,  linewidth=2)\nend \n\nanimp1 = @animate for i = 1:length(tsol)\n    plot(tsol[1:i], p11[1:i], xlim=(0.,8.), ylim=(0.,2.) , label=\"costate p1\", linecolor=:purple,  linewidth=2)\nend ;\n\nanimp2 = @animate for i = 1:length(tsol)\n    plot(tsol[1:i], p22[1:i], xlim=(0.,8.), ylim=(-2.2,6.), label=\"costate p2\", linecolor=:violet,  linewidth=2)\nend \nnothing # hide","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":" # display the animation\ngif(animx, \"zer1_x.gif\", fps = 10)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"gif(animu, \"zer1_u.gif\", fps = 10)","category":"page"},{"location":"zermelo1.html","page":"Zermelo navigation problem: Example 1","title":"Zermelo navigation problem: Example 1","text":"gif(animp2, \"zer1_p2.gif\", fps = 10)","category":"page"},{"location":"ho.html#Harmonic-oscillator-problem","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"","category":"section"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"    left\n    beginarrayl\n        displaystyle min  T 05em\n        dotx_1(t) = x_2(t)  tin 0T05em\n        dotx_2(t) = u(t)-x_1(t) tin 0T  05em\n        u(t) in -1 1  tin 0T05em\n        x(0) = (420)  quad x(T) = 0_mathrmR^2 05em\n        x mid x_2  0 text is a control loss reigon\n    endarray\n    right","category":"page"},{"location":"ho.html#Reformulation-for-the-direct-method","page":"Harmonic oscillator problem","title":"Reformulation for the direct method","text":"","category":"section"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"    left\n    beginarrayl\n        displaystyle min  T + varepsilon int_0^T v^2(t)dt + int_0^T f_NC(x_2(t))u^2(t)dt 05em\n        dotx_1(t) = x_2(t)  tin 0T05em\n        dotx_2(t) =f_C(x_2(t))(u(t) - x_1(t)) + f_NC(x_2(t))(lambda(t) - x_1(t))\n         tin 0T  05em\n        dotlambda(t) = f_C(x_2(t))v(t) tin 0T05em\n        u(t) in -1 1  tin 0T05em\n        x(0) = (420)  quad x(T) = 0_mathrmR^2\n    endarray\n    right","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"    using JuMP  \n    using Ipopt\n    using Plots\n    using Plots.PlotMeasures\n    using LaTeXStrings\n    using OptimalControl\n    using NLPModelsIpopt\n    include(\"smooth.jl\");\n    nothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"a0  = 0.0 \nε1 = 0.018\nfNC(x) = fNC_unboundedminus(x,a0,ε1)\nplot(fNC,-1., 1, label=\"fNC\")","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"  @def ocp begin\n        \n    ε = 1e-3\n\n    tf ∈ R,                          variable\n\n    t ∈ [ 0., tf ],                  time\n\n    q = [ x1, x2, λ, xu, xv ] ∈ R^5, state\n\n    ω = [u, v] ∈ R^2,                control\n\n    tf ≥ 0.\n    \n    #initial conditions\n    x1(0) == 2.5\n    x2(0) == 4\n    xu(0) == 0\n    xv(0) == 0\n\n    #final condition\n    x1(tf) == 0\n    x2(tf) == 0\n\n    #control constraint\n    -1. ≤  u(t)  ≤ 1.\n\n    #state constraint\n    -1 ≤  λ(t) ≤ 1,             (1)\n    -5 ≤ x1(t) ≤ 5,             (2)\n    -5 ≤ x2(t) ≤ 5,             (3)\n\n    #hybrid control system\n    q̇(t) == [x2(t), (1-fNC(x2(t)))*u(t) + fNC(x2(t))*λ(t) - x1(t), (1-fNC(x2(t)))*v(t), (v(t))^2, fNC(x2(t))*(u(t))^2]\n\n    #cost function        \n    tf + ε*xv(tf) + xu(tf) → min    \nend;\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":" N = 630 \nsol = solve(ocp; init = (state = t -> [0.1, 0.1, 1, 0, 0], control =[-1, 0], variable =15), grid_size=N, print_level=4)\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"plot(sol; layout=:group, size=(800, 300))","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"tt    = sol.times\ntf    = tt[end] \nx1(t) = sol.state(t)[1]\nx2(t) = sol.state(t)[2]\nλ(t)  = sol.state(t)[3]\nu(t)  = sol.control(t)[1]\np1(t) = sol.costate(t)[1]\np2(t) = sol.costate(t)[2]\na     = λ(tt[end])\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"plot(x1, x2, 0, tf, label=\"optimal trajectory\", color=\"blue\", linewidth=2)\nplot!([-4, 5], [0, 0], color=:black, label=false, linewidth=2)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"plot(tt, u, label=\"optimal control\", color=\"red\", linewidth=2)\nplot!(tt, λ, label=\"state λ\", color=\"green\", linewidth=2)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"# Find the crossing times based on conditions for x1\nt1_index = findfirst(t -> x2(t) ≤ 0, tt)\nt2_index = nothing\nt3_index = nothing\n\n# If t1 is found, find the next crossing times\nif t1_index !== nothing\n    t2_index = findfirst(t -> x2(t) ≥ 0, tt[t1_index+1:end])\n    t2_index = t2_index !== nothing ? t2_index + t1_index : nothing\nend\n\nif t2_index !== nothing\n    t3_index = findfirst(t -> x2(t) ≤ 0, tt[t2_index+1:end])\n    t3_index = t3_index !== nothing ? t3_index + t2_index : nothing\nend\n\nif t3_index !== nothing\n    t4_index = findfirst(t -> x2(t) ≥ 0, tt[t3_index+1:end])\n    t4_index = t4_index !== nothing ? t4_index + t3_index : nothing\nend\n\n# Convert indices to times\nt1 = t1_index !== nothing ? tt[t1_index] : \"No such t1 found\"\nt2 = t2_index !== nothing ? tt[t2_index] : \"No such t2 found\"\nt3 = t3_index !== nothing ? tt[t3_index] : \"No such t3 found\"\nt4 = tt[end]\n\nprintln(\"First crossing time: \",        t1)\nprintln(\"Second crossing time: \",       t2)\nprintln(\"Third crossing time: \",        t3)\nprintln(\"Fourth crossing/final time: \", t4)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"d = diff(u.(tt))\ntstar = tt[findall(abs.(d) .> 1.5)[]]\nprintln(\"the switching time: \", tstar)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"jmp1 = p2(t1+0.1)  - p2(t1-0.1)\njmp2 = p2(t2+0.1)  - p2(t2-0.1)\n\nprintln(\" p2(t1+) - p2(t1-) = \", jmp1)\nprintln(\" p2(t2+) - p2(t2-) = \", jmp2)","category":"page"},{"location":"ho.html#Indirect-Method","page":"Harmonic oscillator problem","title":"Indirect Method","text":"","category":"section"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"using NonlinearSolve  \nusing OrdinaryDiffEq\nusing Animations","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"\n# Dynamics\nfunction F0(x)\n    return [ x[2], -x[1]]\nend\n\nfunction F1(x)\n    return [ 0.0 ,   1.0]\nend\n\n\nH0(x, p) = p' * F0(x) \nH1(x, p) = p' * F1(x)\n\n# Hamiltonians: \nH(x, p, u)  =  H0(x, p) + u*H1(x,p)                             # pseudo-Hamiltonian\n\nup(x, p) =   1.0\num(x, p) = - 1.0\n\nHp(x, p) = H(x, p, up(x, p))\nHm(x, p) = H(x, p, um(x, p))\n\n\n# Hamiltonians: control loss region 2\nH2(x, b, y, p)  = H0(x, p) + b*H1(x, p) - y*p[2]                # pseudo-Hamiltonian\nHcl(X, P)       = H2(X[1:2], X[3], X[4], P[1:2])                # control loss 2\n\n\n\n# Flows\nfp    = Flow(Hamiltonian(Hp))\nfm    = Flow(Hamiltonian(Hm))\nfcl   = Flow(Hamiltonian(Hcl))\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"# parameters\nt0 = 0.0\nx0 = [2.5; 4.0]","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"# Shooting function\nfunction shoot(p0, tt1, tt2, ttstar, tt3, b1, jump1, jump2, TT) \n    \n    pb0    = 0.0 \n    py0    = 0.0\n        \n    x1, p1 = fm(t0 , x0, p0, tt1) \n    \n    x2, p2 = fp(tt1, x1, p1 - [0. , jump1], tt2)\n    \n    x3, p3 = fp(tt2, x2, p2, ttstar)\n    \n    x4, p4 = fm(ttstar, x3, p3, tt3)\n    \n    X5, P5 = fcl(tt3, [x4 ; b1 ; 0.0], [p4 - [0. , jump2]; pb0 ; py0], TT)\n\n         s = zeros(eltype(p0), 10)\n    \n    s[1:2]  = X5[1:2] - [ 0.0 , 0.0 ]                     # target\n    s[3]    = H1(x3, p3)                                  # switching\n    s[4]    = x1[2] - 0.0                                 # first crossing \n    s[5]    = x2[2] - 0.0                                 # second crossing \n    s[6]    = x4[2] - 0.0                                 # third crossing \n    s[7]    = jump1 - p1[2]*(1. + 1.)/(1. - x1[1])        # jump1\n    s[8]    = jump2 - p4[2]*(b1 + 1.)/(b1 - x4[1])        # jump2\n    s[9]    = Hm(x0, p0) - 1.0                            # free final time\n    s[10]   = P5[4]                                       # averaged gradient condition \n\n    return s\n\nend\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"nle! =  (ξ, λ) -> shoot(ξ[1:2], ξ[3], ξ[4], ξ[5],ξ[6],ξ[7],ξ[8], ξ[9], ξ[10])\nξ_guess = [p1(0) , p2(0), t1, t2, tstar , t3, a, jmp1, jmp2, t4]; # initial guess\nprob = NonlinearProblem(nle!, ξ_guess)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"#solve\nindirect_sol = solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true))","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"# Retrieves solution\n     pp0     = indirect_sol[1:2]\n     tt1     = indirect_sol[3]\n     tt2     = indirect_sol[4]\n     ttstar  = indirect_sol[5]\n     tt3     = indirect_sol[6]\n     b11     = indirect_sol[7]\n     jmp1    = indirect_sol[8]\n     jmp2    = indirect_sol[9]\n     T1      = indirect_sol[10]\n nothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"ode_sol = fm((t0, tt1), x0, pp0, saveat=0.1) \nttt1    = ode_sol.t \nxx1     = [ ode_sol[1:2, j] for j in 1:size(ttt1, 1) ] \npp1     = [ ode_sol[3:4, j] for j in 1:size(ttt1, 1) ] \nuu1     = um.(xx1, pp1)\n\node_sol = fp((tt1, tt2), xx1[end], pp1[end] - [0., jmp1], saveat=0.1) \nttt2    = ode_sol.t ;\nxx2     = [ ode_sol[1:2, j] for j in 1:size(ttt2, 1) ] \npp2     = [ ode_sol[3:4, j] for j in 1:size(ttt2, 1) ] \nuu2     = up.(xx2, pp2)  \n\node_sol = fp((tt2, ttstar), xx2[end], pp2[end] , saveat=0.1) \nttt3    = ode_sol.t ;\nxx3     = [ ode_sol[1:2, j] for j in 1:size(ttt3, 1) ] \npp3     = [ ode_sol[3:4, j] for j in 1:size(ttt3, 1) ] \nuu3     = up.(xx3, pp3)  \n\n\node_sol = fm((ttstar, tt3), xx3[end], pp3[end], saveat=0.1) \nttt4    = ode_sol.t ;\nxx4     = [ ode_sol[1:2, j] for j in 1:size(ttt4, 1) ] \npp4     = [ ode_sol[3:4, j] for j in 1:size(ttt4, 1) ] \nuu4     = um.(xx4, pp4)  \n\node_sol = fcl((tt3, T1), [xx4[end] ; b11 ; 0.0], [pp4[end] - [0., jmp2]; 0. ; 0.], saveat=0.1)\nttt5    = ode_sol.t\nxx5     = [ ode_sol[1:2, j] for j in 1:size(ttt5, 1) ]\npp5     = [ ode_sol[5:6, j] for j in 1:size(ttt5, 1) ] \nuu5     = b11.*ones(length(ttt5)) \nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"tt0 = [ ttt1 ; ttt2 ; ttt3 ; ttt4 ; ttt5 ]\nxx = [ xx1 ; xx2 ; xx3 ; xx4 ; xx5 ]\npp = [ pp1 ; pp2 ; pp3 ; pp4 ; pp5 ]\nuu = [ uu1 ; uu2 ; uu3 ; uu4 ; uu5 ]\n\nm = length(tt0)\n\nx11 = [ xx[i][1] for i=1:m ]\nx22 = [ xx[i][2] for i=1:m ]\np11 = [ pp[i][1] for i=1:m ]\np22 = [ pp[i][2] for i=1:m ]\nnothing # hide","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"plot(x11, x22, label=\"optimal trajectory\",  linecolor=:blue , linewidth=2)\nplot!([-4, 5], [0, 0], color=:black, label=false, linewidth=2)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"plot(tt0,   uu, label=\"optimal control\",  linecolor=:red , linewidth=2) ","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"plot(tt0,  p11, label=\"costate p1\", linecolor=:purple , linewidth=2)\nplot!(tt0,  p22, label=\"costate p2\",  linecolor=:violet , linewidth=2)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"# create an animation\n\nanimx = @animate for i = 1:length(tt0)\n    plot(x11[1:i], x22[1:i], xlim=(-3.,5.), ylim=(-4.,4.3), label=\"optimal trajectory\", linecolor=:blue,  linewidth=2)\n    scatter!([x11[i]], [x22[i]], markersize=4, marker=:circle, color=:black, label=false)\n    plot!([-4, 5], [0, 0], color=:black, label=false, linewidth=2)\n\nend\nanimu = @animate for i = 1:length(tt0)\n    plot(tt0[1:i], uu[1:i], xlim=(0.,tt0[end]), ylim=(-1.2,1.2), label=\"opitmal control\", linecolor=:red,  linewidth=2)\nend \n\nanimp1 = @animate for i = 1:length(tt0)\n    plot(tt0[1:i], p11[1:i], xlim=(0.,tt0[end]), ylim=(-1.3, 0.5),label=\"costate p1\", linecolor=:purple,  linewidth=2)\nend ;\n\nanimp2 = @animate for i = 1:length(tt0)\n    plot(tt0[1:i], p22[1:i], xlim=(0.,tt0[end]), ylim=(-1.5,1.3), label=\"costate p2\", linecolor=:violet,  linewidth=2)\nend ","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"# display the animation\ngif(animx, \"ho_x.gif\",   fps = 10)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"gif(animu, \"ho_u.gif\",   fps = 10)","category":"page"},{"location":"ho.html","page":"Harmonic oscillator problem","title":"Harmonic oscillator problem","text":"gif(animp2, \"ho_p2.gif\", fps = 10)","category":"page"},{"location":"numerical.html#A-numerical-approach-for-optimal-control-problems-with-loss-control-regions","page":"Numerical approach","title":"A numerical approach for optimal control problems with loss control regions","text":"","category":"section"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"In optimal control theory, there are several ways for solving numerically an optimal control problem. Direct and indirect methods represent an important class of methods that we will use hereafter. ","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Direct methods involve discretizing the state and control variables, simplifying the problem into a finite-dimensional nonlinear optimization problem. On the other hand, indirect methods tackle the problem by solving a boundary value problem, based on the PMP, through the use of a shooting method (see, e.g.[1],[2]). ","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"It is important to note that neither of these methods is fundamentally better than the other. Indeed, each of these methods has its pros and cons. For instance, although the direct method is simple to implement, more robust and less sensitive to the choice of the initial condition, it should be noted that it yields less precise results and can converge to local minima that significantly deviate from the optimal solution. Additionally, this method requires a large amount of memory. On the other hand, the indirect method is known for its extreme precision. However, it is based only on necessary optimality conditions from the PMP and often requires knowledge of the structure of the optimal solution. Moreover, it is quite sensitive to the choice of the initial condition, which must be chosen carefully to ensure convergence.","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Often in the literature, one proceeds in two steps. The first step is to implement a direct method to determine the optimal solution's structure and extract the associated adjoint vector. The second step involves constructing an indirect shooting method, where the initial condition is based on the numerical results obtained from the direct method.","category":"page"},{"location":"numerical.html#Description-of-the-direct-method","page":"Numerical approach","title":"Description of the direct method","text":"","category":"section"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"For some omega_0 in mathrmU, some varepsilon_00 and varepsilon0 small enough, we introduce the regularized problem given by","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"beginequation\nbeginarraylcl\n     textminimize   phi(x(0)x(T)) + varepsilon_0 displaystyleint_0^T v^2(t)  dt + displaystyleint_0^T (1- Psi_varepsilon(x(t)))u(t)-omega_0_R^m^2  dt10pt\n     textsubject to   (xlambdauv) in mathrmAC(0TR^n) times mathrmAC(0TR^m) times mathrmL^infty(0TR^m)times mathrmL^infty(0TR) 2pt\n       dotx(t) = Psi_varepsilon(x(t)) f(x(t)u(t)) + (1-Psi_varepsilon(x(t))) f(x(t)lambda(t)) quad textae  tin 0T 2pt\n       dotlambda(t) =Psi_varepsilon(x(t))v(t) quad textae  tin 0T 2pt\n        g(x(0)x(T)) in mathrmS 2pt\n        lambda(t)   in mathrmU quad textae  tin 0T2pt\n        (u(t)v(t)) in  mathrmU times R  quad textae  tin 0T\n     endarray\nendequation","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"where Psi_epsilon  R^n to R is the regularization of the characteristic function of cup_q_j = 1 overlineX_j given by ","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Psi_varepsilon(x) = sum_q_j = 1 e^-frac12 varepsilon mathrmd^2_j(x)","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"for all xin R^n, where mathrmd_j R^n to R stands for the distance function to the set overlineX_j defined by mathrmd_j(x) = inf_y in overlineX_j x-y_R^n for all xin R^n and every j in mathcalJ. ","category":"page"},{"location":"numerical.html#Description-of-the-indirect-method","page":"Numerical approach","title":"Description of the indirect method","text":"","category":"section"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Recall that the direct method has captured the structure of the optimal pair (x^*u^*). In the indirect method, we address each arc separately.  We begin by defining the flow of the Hamiltonian associated with each arc. To accomplish this, we use the function Flow that can be found in the CTFlows.jl package. This latter allows to solve the Hamiltonian system over a given time interval from given initial values of the state and the adjoint vector. This function requires necessary libraries such as  ForwardDiff for calculating gradients and Jacobians and  OrdinaryDiffEq for solving ordinary differential equations. ","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"In the setting of the present paper (including control regions and loss control regions), we distinguish between two types of Hamiltonian flows:","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Hamiltonian flows in control regions We recall that the Hamiltonian  H associated with the optimal control problem given above is defined by","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"H(xup) = langle  p f(xu)rangle_R^n","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"for all (xup)in mathbbR^n times mathbbR^m times mathbbR^n. Using the theorem given above and more specifically the Hamiltonian maximization condition, we obtain an expression of the control u^* which can generate a sequence of arcs. Then it remains to define a pseudo-Hamiltonian (the pseudo-Hamiltonian stands for the Hamiltonian flow associated with each arc). associated with each arc. Finally we define the flow associated with each arc, which allows the resolution of the boundary value problem on a time interval satisfied by the pair (x^*p) with an initial condition.","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Hamiltonian flows in loss control regions Recall that, in loss control regions,  u^* satisfies an averaged Hamiltonian gradient condition (see Theorem above). Here, the difficulty lies in the fact that this condition is given in an integral and implicit form. Therefore, to overcome this difficulty, we first introduce new states  lambda and  y. First, the state lambda comes from the augmentation technique (we refer to [3] for more details) to handle the constant value  u^*_k, so it satisfies the dynamics  dotlambda(t)=0 and the initial condition  lambda(tau^*_k-1) = u^*_k. Second, the state y satisfies doty(t) = 0 and y(tau^*_k-1)=0 (and thus y=0). Now we define the new Hamiltonian  tildeH as follows:","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"tildeH(xuyp) \n            = H(xup) - y nabla_u H(xup) = langle  p f(xu)rangle_R^n - y nabla_u H(xup)","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"for all  (xuyp)in mathbbR^n times mathbbR^m times R times mathbbR^n   It is important to note that since y=0, we recover the same Hamiltonian  H. But, the actual utility of introducing the state  y is that it allows us to rewrite the integral expressed in the averaged Hamiltonian gradient condition as a terminal value of an adjoint vector. This makes it easier to take into account in the shooting function. Here is the justification of this point. First, we define  p_y as the solution to the  system","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"    leftbeginarrayl\n     dotp_y(t) = - nabla_y tildeH(x^*(t)u^*_ky(t)p(t)) quad\n     textfor ae  tin tau^*_k-1 tau^*_k  \n    p_y(tau^*_k-1) = 0_R^n\n    endarray\n    right","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Second, since  u_k^* is assumed to be an interior value to  mathrmU, we get that","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"beginequation*\n    int_tau^*_k-1^tau^*_k nabla_u H(x^*(t)u^*_kp(t))  dt = p_y(tau^*_k)=0\nendequation*","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"Hence there is no need to compute an integral in order to take into account the averaged Hamiltonian gradient condition. ","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"[1]: S. Aronna, F. Bonnans, P. Martinon, A shooting algorithm for optimal control problems with singular arcs, Journal of Optimization Theory and Applications, 158, pp. 419–459, Springer, 2013.","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"[2]: J.F. Bonnans, The shooting approach to optimal control problems, IFAC Proceedings Volumes, 46, no. 11, pp. 281–292, Elsevier, 2013.","category":"page"},{"location":"numerical.html","page":"Numerical approach","title":"Numerical approach","text":"[3]: T. Bayen, A. Bouali, L. Bourdin & O. Cots, Loss control regions in optimal control problems, Journal of Differential Equations, 405 (2024), 359-397.","category":"page"},{"location":"zermelo2.html#Zermelo-problem,-example-2","page":"Zermelo navigation problem: Example 2","title":"Zermelo problem, example 2","text":"","category":"section"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"\n    left\n    beginarrayl\n        displaystyle min - x_1(8) 05em\n        dotx_1(t) = x_2(t) + cos(u(t))  textfor ae  tin 0805em\n        dotx_2(t) = sin(u(t))   textfor ae  tin 08 05em\n        u(t) in -fracpi2 fracpi2  textfor ae  tin 08 05em\n        x(0) = 0_mathbbR^2 quad x_2(8) = 405em\n        x in mathbbR^2 mid 5  x_1  10  text and  x in mathbbR^2 mid 20  x_1  25  text are loss control regions\n    endarray\n    right","category":"page"},{"location":"zermelo2.html#Reformulation-for-the-direct-method","page":"Zermelo navigation problem: Example 2","title":"Reformulation for the direct method","text":"","category":"section"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"\n    left\n    beginarrayl\n        displaystyle min - x_1(8) + varepsilon int_0^8 v^2(t)dt + int_0^8 f_NC(x(t))u^2(t)dt 05em\n        dotx_1(t) = f_C(x(t)) (x_2(t) + cos(u(t)))+f_NC(x(t)) (x_2(t) + cos(lambda(t)))  textfor ae  tin 0805em\n        dotx_2(t) =  f_C(x(t)) sin(u(t))+f_NC(x(t)) sin(lambda(t))   textfor ae  tin 08 05em\n        dotlambda(t) = f_C(x(t))v(t)   textfor ae  tin 08 05em\n        u(t)in -fracpi2 fracpi2   textfor ae  tin 08 05em\n        x(0) = 0_mathbbR^2 quad x_2(8) = 405em\n        x in mathbbR^2 mid 5  x_1  10  text and  x in mathbbR^2 mid 20  x_1  25  text are loss control regions\n    endarray\n    right","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"using JuMP  \nusing Ipopt\nusing Plots\nusing Plots.PlotMeasures\nusing LaTeXStrings\nusing OptimalControl\nusing NLPModelsIpopt\ninclude(\"smooth.jl\")\nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"I2 = [(5, 10), (20, 25)]\nε2 = 0.05  \nfNC2(x) = fNC_bounded(x,I2,ε2)\nplot(fNC2,0., 30, label=\"fNC\")","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"@def ocp2 begin\n\n    ϵ  = 1e-3\n    \n    tf = 8\n\n    t ∈ [ 0., tf ],                  time\n\n    q = [ x1, x2, λ, xu, xv ] ∈ R^5, state\n\n    ω = [u, v] ∈ R^2,                control\n\n    #initial conditions\n    x1(0) == 0\n    x2(0) == 0\n    xu(0) == 0\n    xv(0) == 0\n\n    #final condition\n    x2(tf) == 4\n\n    #control constraint\n    -π/2  ≤  u(t)  ≤ π/2\n\n    #state constraints\n    -π/2  ≤  λ(t)  ≤ π/2\n\n    #hybrid control system\n     q̇(t) == [fNC2(x1(t))*(x2(t) + cos(λ(t))) + (1-fNC2(x1(t)))*(x2(t) + cos(u(t))),\n             fNC2(x1(t))*sin(λ(t)) + (1-fNC2(x1(t)))*sin(u(t)),\n             (1-fNC2(x1(t)))*v(t),\n             (v(t))^2,\n             fNC2(x1(t))*(u(t))^2]\n\n    #cost function        \n    -x1(tf) + ϵ*xv(tf) + xu(tf) → min    \nend\nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"N = 400\nsol2 = solve(ocp2; grid_size=N, print_level=4)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"plot(sol2; layout=:group, size=(800, 300))","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"tt2   = sol2.times\ntf    = 8\ny1(t) = sol2.state(t)[1]\ny2(t) = sol2.state(t)[2]\nμ(t)  = sol2.state(t)[3]\nv(t)  = sol2.control(t)[1]\nq1(t) = sol2.costate(t)[1]\nq2(t) = sol2.costate(t)[2]\nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"plot(y1, y2, 0, tf, label=\"optimal trajectory\", color=\"blue\", linewidth=2)\nplot!([5, 5], [0, 6], color=:black, label = false, linewidth=2)\nplot!([10, 10], [0,6], color=:black, label = false, linewidth=2)\nplot!([20, 20], [0, 6], color=:black, label = false, linewidth=2)\nplot!([25, 25], [0,6], color=:black, label = false, linewidth=2)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"plot(tt2, v, label=\"optimal control\", color=\"red\", linewidth=2)\nplot!(tt2, μ, label=\"state λ\", color=\"green\", linewidth=2)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"plot(tt2, q1, label=\"costate p1\", color=\"purple\", linewidth=2)\nplot!(tt2, q2, label=\"costate p2\", color=\"violet\", linewidth=2)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# Find the crossing times based on conditions for x1\ns1_index = findfirst(t -> y1(t) > 5, tt2)\ns2_index = nothing\ns3_index = nothing\ns4_index = nothing\n\n# If t1 is found, find the next crossing times\nif s1_index !== nothing\n    s2_index = findfirst(t -> y1(t) > 10, tt2[s1_index+1:end])\n    s2_index = s2_index !== nothing ? s2_index + s1_index : nothing\nend\n\nif s2_index !== nothing\n    s3_index = findfirst(t -> y1(t) > 20, tt2[s2_index+1:end])\n    s3_index = s3_index !== nothing ? s3_index + s2_index : nothing\nend\n\nif s3_index !== nothing\n    s4_index = findfirst(t -> y1(t) > 25, tt2[s3_index+1:end])\n    s4_index = s4_index !== nothing ? s4_index + s3_index : nothing\nend\n\n# Convert indices to times\ns1 = s1_index !== nothing ? tt2[s1_index] : \"No such t1 found\"\ns2 = s2_index !== nothing ? tt2[s2_index] : \"No such t2 found\"\ns3 = s3_index !== nothing ? tt2[s3_index] : \"No such t3 found\"\ns4 = s4_index !== nothing ? tt2[s4_index] : \"No such t4 found\"\n\nprintln(\"First crossing time: \",  s1)\nprintln(\"Second crossing time: \", s2)\nprintln(\"Third crossing time: \",  s3)\nprintln(\"Fourth crossing time: \", s4)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# extract constant values of λ\nb1 = μ((s1+s2)/2)\nb2 = μ((s3+s4)/2)\nprintln(\"First constant value of λ: \",  b1)\nprintln(\"Second constant value of λ: \", b2)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"jmp1 = q1(s1+0.1)  - q1(s1-0.1)\njmp2 = q1(s2+0.1)  - q1(s2-0.1)\njmp3 = q1(s3+0.1)  - q1(s3-0.1)\njmp4 = q1(s4+0.1)  - q1(s4-0.1)\n\n\nprintln(\" p1(t1+) - p1(t1-) = \", jmp1)\nprintln(\" p1(t2+) - p1(t2-) = \", jmp2)\nprintln(\" p1(t3+) - p1(t3-) = \", jmp3)\nprintln(\" p1(t4+) - p1(t4-) = \", jmp4)","category":"page"},{"location":"zermelo2.html#Indirect-Method","page":"Zermelo navigation problem: Example 2","title":"Indirect Method","text":"","category":"section"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"using NonlinearSolve  \nusing OrdinaryDiffEq\nusing Animations","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# Dynamics\nfunction F(x, u)\n    return [ x[2] + cos(u), sin(u) ]\nend\n\nfunction G(λ)\n    return [ sin(λ), - cos(λ) ]\nend\n\n# Hamiltonian: permanent region\nH1(x, u, p)  = p' * F(x, u)                 # pseudo-Hamiltonian\nu11(x, p)    = atan(p[2]/p[1])              # maximizing control\nHc(x, p)     = H1(x, u11(x, p) , p )        # Hamiltonian\n\n# Flow\nfc  = Flow(Hamiltonian(Hc))\n\n# Hamiltonian: control loss region\nH2(x, λ, y, p)   = p' * F(x, λ)   + y* p' *G(λ)    # pseudo-Hamiltonian\nHcl(X, P)        = H2(X[1:2], X[3], X[4], P[1:2])  # Hamiltonian\n\n# Flow\nfcl = Flow(Hamiltonian(Hcl))\nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# parameters\nt0  = 0\ntf  = 8\nx2f = 4\nx0  = [0, 0]\nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# Shooting function\nfunction shoot2(p0, tt1, tt2, tt3, tt4, λ1, λ3, j1, j2, j3, j4) \n    \n    pλ0    = 0\n    qy0    = 0\n    \n    y1, q1 =  fc(t0, x0, p0, tt1)\n    Y2, Q2 = fcl(tt1, [y1; λ1; 0], [q1 - [j1 , 0]; pλ0 ; qy0], tt2) \n    y3, q3 =  fc(tt2, Y2[1:2], Q2[1:2] - [j2 , 0], tt3)\n    Y4, Q4 = fcl(tt3, [y3; λ3; 0], [q3 - [j3 , 0]; pλ0 ; qy0], tt4)\n    yf, qf =  fc(tt4, Y4[1:2], Q4[1:2] - [j4 , 0], tf)\n\n    s = zeros(eltype(p0), 12)\n    s[1]  = yf[2] - x2f   # target\n    s[2]  = qf[1] - 1     # transversality condition\n    s[3]  = y1[1] - 2     # first crossing \n    s[4]  = Y2[1] - 16    # second crossing \n    s[5]  = y3[1] - 20    # first crossing \n    s[6]  = Y4[1] - 25    # second crossing \n    s[7]  = Q2[4]         # averaged gradient condition1\n    s[8]  = Q4[4]         # averaged gradient condition2\n\n    v_temp = u11(y1, q1)\n    s[9]  = j1 - (q1[1]*(cos(λ1) - cos(v_temp)) + \n                  q1[2]*(sin(λ1) - sin(v_temp)))/(y1[2] + cos(λ1))    # jump 1\n\n    v_temp = u11(Y2[1:2], Q2[1:2])\n    s[10] = j2 - (Q2[1]*(cos(v_temp) - cos(λ1)) + \n                  Q2[2]*(sin(v_temp) - sin(λ1)))/(Y2[2]+cos(v_temp))  # jump 2\n\n    v_temp = u11(y3, q3)\n    s[11] = j3 - (q3[1]*(cos(λ3) - cos(v_temp)) + \n                  q3[2]*(sin(λ3) - sin(v_temp)))/(y3[2] + cos(λ3))    # jump 3\n                  \n    v_temp = u11(Y4[1:2], Q4[1:2])\n    s[12] = j4 - (Q4[1]*(cos(v_temp) - cos(λ3)) + \n                  Q4[2]*(sin(v_temp) - sin(λ3)))/(Y4[2]+cos(v_temp))  # jump 4\n\n    return s\n\nend\nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"nle! =  (ξ, λ) -> shoot2(ξ[1:2], ξ[3], ξ[4], ξ[5], ξ[6], ξ[7], ξ[8], ξ[9], ξ[10], ξ[11], ξ[12])\nξ_guess =[q1(0), q2(0), s1, s2, s3, s4, b1, b2, jmp1, jmp2, jmp3, jmp4];            # initial guess\nprob = NonlinearProblem(nle!, ξ_guess)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"#solve\nindirect_sol2 = solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true))","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# Retrieves solution\n    qq0 = indirect_sol2[1:2]\n    ss1 = indirect_sol2[3]\n    ss2 = indirect_sol2[4]\n    ss3 = indirect_sol2[5]\n    ss4 = indirect_sol2[6]\n    bb1 = indirect_sol2[7]\n    bb2 = indirect_sol2[8]\n    j11 = indirect_sol2[9]\n    j22 = indirect_sol2[10]\n    j33 = indirect_sol2[11]\n    j44 = indirect_sol2[12]","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# jumps from indirect solution\nprintln(\" jumps from indirect solution\")\nprintln(\" p1(t1+) - p1(t1-) = \", j11)\nprintln(\" p1(t2+) - p1(t2-) = \", j22)\nprintln(\" p1(t3+) - p1(t3-) = \", j33)\nprintln(\" p1(t4+) - p1(t4-) = \", j44)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"qa0 = 0 \nqb0 = 0\nqy0 = 0\nqz0 = 0\n\node_sol = fc((t0, ss1), x0, qq0, saveat=0.1) \nttt1    = ode_sol.t ;\nyy1     = [ ode_sol[1:2, j] for j in 1:size(ttt1, 1) ] \nqq1     = [ ode_sol[3:4, j] for j in 1:size(ttt1, 1) ] \nvv1     = u11.(yy1, qq1)  \n\node_sol = fcl((ss1, ss2), [yy1[end] ; bb1 ; 0.0], [qq1[end] - [ j11, 0.]; qa0 ; qy0], saveat=0.1)\nttt2    = ode_sol.t\nyy2     = [ ode_sol[1:2, j] for j in 1:size(ttt2, 1) ]\nqq2     = [ ode_sol[5:6, j] for j in 1:size(ttt2, 1) ]\nvv2     = bb1.*ones(length(ttt2)) \n\node_sol = fc((ss2, ss3), yy2[end],  qq2[end] - [j22, 0.], saveat=0.1)\nttt3    = ode_sol.t\nyy3     = [ ode_sol[1:2, j] for j in 1:size(ttt3, 1) ]\nqq3     = [ ode_sol[3:4, j] for j in 1:size(ttt3, 1) ] \nvv3     = u11.(yy3, qq3)\n\node_sol = fcl((ss3, ss4), [yy3[end] ; b2 ; 0.0], [qq3[end] - [j33, 0.]; qb0 ; qz0], saveat=0.1)\nttt4    = ode_sol.t\nyy4     = [ ode_sol[1:2, j] for j in 1:size(ttt4, 1) ]\nqq4     = [ ode_sol[5:6, j] for j in 1:size(ttt4, 1) ] \nvv4     = bb2.*ones(length(ttt4)) \n\node_sol = fc((ss4, tf), yy4[end], qq4[end]- [j44, 0.], saveat=0.1)\nttt5 = ode_sol.t\nyy5 = [ ode_sol[1:2, j] for j in 1:size(ttt5, 1) ]\nqq5 = [ ode_sol[3:4, j] for j in 1:size(ttt5, 1) ] \nvv5 = u11.(yy5, qq5)  \n\nttt = [ ttt1 ; ttt2 ; ttt3 ; ttt4 ; ttt5]\nyyy = [ yy1 ; yy2 ; yy3 ; yy4 ; yy5 ]\nqqq = [ qq1 ; qq2 ; qq3 ; qq4 ; qq5 ]\nvvv = [ vv1 ; vv2 ; vv3 ; vv4 ; vv5 ]\n\nm = length(ttt)\n\nyy1 = [ yyy[i][1] for i=1:m ]\nyy2 = [ yyy[i][2] for i=1:m ]\nqq1 = [ qqq[i][1] for i=1:m ]\nqq2 = [ qqq[i][2] for i=1:m ] \nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"plot(yy1, yy2, label=\"optimal trajectory\", legend=false, linecolor=:blue, linewidth=2)\nplot!([5, 5], [0, 6], color=:black, label = false, linewidth=2)\nplot!([10, 10], [0,6], color=:black, label = false, linewidth=2)\nplot!([20, 20], [0, 6], color=:black, label = false, linewidth=2)\nplot!([25, 25], [0,6], color=:black, label = false, linewidth=2)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"plot(ttt,   vvv, label=\"optimal control\" ,linecolor=:red ,linewidth=2)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"plot(ttt, qq1, label=\"costate p1\", linecolor=:purple, linewidth=2)\nplot!(ttt,  qq2, label=\"costate p2\", linecolor=:violet, linewidth=2)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"# create an animation\nanimy = @animate for i = 1:length(ttt)\n    plot(yy1[1:i], yy2[1:i],  xlim=(0.,31.), ylim=(-0.,5.5),  label=\"optimal trajectory\", linecolor=:blue,  linewidth=2)\n    scatter!([yy1[i]], [yy2[i]], markersize=4, marker=:circle, color=:black, label=false)\n    plot!([5,   5], [0, 6], color=:black, label = false, linewidth=2)\n    plot!([10, 10], [0, 6], color=:black, label = false, linewidth=2)\n    plot!([20, 20], [0, 6], color=:black, label = false, linewidth=2)\n    plot!([25, 25], [0, 6], color=:black, label = false, linewidth=2)\nend\n\nanimv = @animate for i = 1:length(ttt)\n    plot(ttt[1:i], vvv[1:i], xlim=(0.,8.), ylim=(-pi/2,pi/2), label=\"opitmal control\", linecolor=:red,  linewidth=2)\nend \n\nanimq1 = @animate for i = 1:length(ttt)\n    plot(ttt[1:i], qq1[1:i], xlim=(0.,8.), ylim=(0.,2.) , label=\"costate p1\", linecolor=:purple,  linewidth=2)\nend ;\n\nanimq2 = @animate for i = 1:length(ttt)\n    plot(ttt[1:i], qq2[1:i], xlim=(0.,8.), ylim=(-2.2,6.), label=\"costate p2\", linecolor=:violet,  linewidth=2)\nend \nnothing # hide","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"gif(animy, \"zer2_y.gif\",   fps = 10)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"gif(animv, \"zer2_v.gif\",   fps = 10)","category":"page"},{"location":"zermelo2.html","page":"Zermelo navigation problem: Example 2","title":"Zermelo navigation problem: Example 2","text":"gif(animq1, \"zer2_q1.gif\", fps = 10)","category":"page"},{"location":"statement.html#Statement-of-the-problem","page":"Statement of the problem","title":"Statement of the problem","text":"","category":"section"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"Let n, m, ell in mathbbN^* be three positive integers and T  0 be a positive real number. In this section, we consider a partition of the state space given by","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"mathbbR^n = bigcup_j in mathcalJ overlineX_j","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"where mathcalJ is a (possibly infinite) family of indexes and the nonempty open subsets X_j subset mathbbR^n, called regions, are disjoint. We introduce an indexation q_j in 0 1 allowing us to separate control regions and loss control regions (see Introduction for details) as follows","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"q_j = begincases\n1 text if  X_j text is a control region \n0 text if  X_j text is a loss control region\nendcases","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"for all j in mathcalJ.","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"Our aim in this section is to derive first-order necessary optimality conditions in a Pontryagin form for the optimal control problem with loss control regions given by","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"beginaligned\ntextminimize  quad phi(x(0)x(T)) \ntextsubject to  quad (xu) in mathrmAC(0TmathbbR^n) times mathrmL^infty(0TmathbbR^m) \n quad dotx(t) = f(x(t) u(t)) quad textae  t in 0T \n quad g(x(0)x(T)) in mathrmS \n quad u(t) in mathrmU quad textae  t in 0T \n quad u text is constant when x is in a loss control region\nendaligned","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"where the Mayer cost function phi mathbbR^n times mathbbR^n to mathbbR, the dynamics f mathbbR^n times mathbbR^m to mathbbR^n, and the constraint function g mathbbR^n times mathbbR^n to mathbbR^ell are of class mathrmC^1, and where both subsets mathrmS subset mathbbR^ell and mathrmU subset mathbbR^m are nonempty closed convex subsets.","category":"page"},{"location":"statement.html#Regular-solution-to-the-control-system-with-loss-control-regions","page":"Statement of the problem","title":"Regular solution to the control system with loss control regions","text":"","category":"section"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"First, let us provide the definition of a solution to the following control system","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"beginequation*\nleftlbrace \nbeginarrayl\ndotx(t) = f(x(t)u(t))  quad textfor ae  t in 0T  2pt\nu text is constant when  x text is in a loss control region\nendarray\nright\nquad text(CS)\nendequation*","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"note: Definition (Solution to (CS))\nA pair (xu) in mathrmAC(0TR^n) times mathrmL^infty(0TR^m) is said to be a solution to (CS) if there exist a finite number mathbbN^* and a partition mathbbT = tau_k_k=0ldotsN of the interval 0T such that:               It holds that    forall k in  1ldotsN  quad exists j(k) in mathcalJ quad forall t in (tau_k-1tau_k) quad x(t) in X_j(k) where j(k) neq j(k-1) for all k in  2ldotsN . The sequence j(1)ldots j(N) is called the switching sequence.It holds that x(0) in X_j(1) and x(T) in X_j(N).\nFor all k in 1 ldots N such that q_j(k)=0, the control u is constant over (tau_k-1 tau_k) (the constant value being denoted by u_k in the sequel).\nIt holds that dot x(t)=f(x(t)u(t)) for almost every t in 0T.The times tau_k for k in 1ldotsN-1, called  \\textit{crossing times}, correspond to the instants at which the trajectory x goes from the region X_j(k) to the region X_j(k+1), and thus x(tau_k) in partial X_j(k) cap partial X_j(k+1). ","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"The PMP with loss control regions is based on some regularity assumptions made on the optimal pair of the optimal control problem with loss control regions given above at each of its crossing times. These hypotheses are made more precise in the next definition.","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"note: Definition (Regular solution to (CS))\nFollowing the notations introduced in Definition given above, a solution (xu) in mathrmAC(0TR^n) times mathrmL^infty(0TR^m) to (CS), associated with a finite number N in mathbbN^*, a partition mathbbT =  tau_k _k=0ldotsN and a switching sequence j(1) ldots j(N), is said to be regular if the following conditions are both satisfied:At each crossing time tau_k, there exists a mathrmC^1 function F_k  R^n to R such that     beginequation\n        exists nu_k  0 quad\n        forall z in  overlinemathrmB_R^n(x(tau_k)nu_k) quad  \n        left\n        beginarrayrcl \n            z in X_j(k)  Leftrightarrow  F_k(z)0 2pt\n            z in partial X_j(k)cap partial X_j(k+1)  Leftrightarrow  F_k(z)=0 2pt\n            z in X_j(k+1)  Leftrightarrow  F_k(z)0\n        endarray\n        right\n    endequationIn particular it holds that F_k(x(tau_k))=0.At each crossing time tau_k, there exists alpha_k0 and beta_k  0 such that the transverse conditionbeginequation\nlangle  nabla F_k(x(tau_k))  f(x(tau_k)u(t)) rangle_R^n geq beta_k  quad textae  t in tau_k- alpha_k tau_k+alpha_k\nendequationis satisfied.","category":"page"},{"location":"statement.html#Pontryagin-maximum-principle-with-loss-control-regions","page":"Statement of the problem","title":"Pontryagin maximum principle with loss control regions","text":"","category":"section"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"The Hamiltonian H  R^n times R^m times R^n to R associated with Problem \\eqref{P} is defined by","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":" H(xup) = langle  p  f(xu) rangle_R^n","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"for all (xup) in R^n times R^m times R^n. We are now in a position to state the main result of this section.","category":"page"},{"location":"statement.html","page":"Statement of the problem","title":"Statement of the problem","text":"tip: Theorem\nIf (x^*u^*)in mathrmAC(0TR^n) times mathrmL^infty(0TR^m) is a global solution to the above problem, that is moreover a regular solution to (CS), associated with a finite number N in mathbbN^*, a partition mathbbT^* =  tau^*_k _k=0ldotsN and a switching sequence j(1)ldotsj(N), and such that g is submersive at (x^*(0)x^*(T)), then there exists a nontrivial pair (pp^0) in mathrmPAC_mathbbT^*(0TR^n) times R_+ satisfying:the Hamiltonian systembeginequation*\ndotx^*(t) = nabla_p H(x^*(t)u^*(t)p(t)) quad textand quad\n-dotp(t) = nabla_x H(x^*(t)u^*(t)p(t))\nendequation*for almost every t in 0T;the transversality conditionbeginequation*\nleft( beginarrayc\np(0) 5pt\n-p(T) \nendarray right)\n= p^0 nabla phi (x^*(0)x^*(T)) + nabla g (x^*(0)x^*(T)) xi\nendequation*for some xi in mathrmN_mathrmS g (x^*(0)x^*(T)) ;the discontinuity conditionbeginequation*\np^+(tau^*_k) - p^-(tau^*_k) =  sigma_k\nnabla F^*_k(x^*(tau^*_k))\nendequation*for some sigma_k in R and for all k in  1ldots  N-1; the Hamiltonian maximization conditionbeginequation*\n    u^*(t) in mathrmargmax_omega in mathrmUH(x^*(t)omegap(t))\nendequation*for almost every tin (tau^*_k-1tau^*_k) and all k in 1ldotsN such that q_j(k)=1;the averaged Hamiltonian gradient conditionbeginequation*\n   int_tau^*_k-1^tau^*_k nabla_u H(x^*(t)u^*_kp(t)) dt in mathrmN_mathrmUu^*_k\nendequation*for all k in 1ldotsN such that q_j(k)=0;the Hamiltonian constancy condition H(x^*(t)u^*(t)p(t)) = cfor almost every tin 0T, for some c in R.","category":"page"},{"location":"index.html#Loss-control-regions-in-optimal-control-problems","page":"Introduction","title":"Loss control regions in optimal control problems","text":"","category":"section"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"General context. Optimal control theory studies controlled systems to achieve desired targets with minimal cost. The Pontryagin maximum principle (PMP, in short) provides necessary conditions for optimality, ensuring an adjoint vector (or costate) meets the Hamiltonian maximization condition[1].","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Typically, optimal control involves permanent control, allowing modification of the control function at each time instant. However, practical constraints can lead to nonpermanent control. For instance, digital controls result in sampled-data control with discrete changes[3],[4]. In aerospace, eclipse constraints limit control for solar-powered satellites in a shadow region where the control is reduced to zero[5]. Hence, it is desirable to keep the system outside these regions.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: aerospace) ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Objective and approach. Here, we address optimal control problems with loss control regions (we refer to [2] for further details), where the state space is divided into control regions and loss control regions. In control regions, control can change at any time, while in loss control regions, control must remain constant, though its value is to be optimized and can vary with each visit.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We extend our previous work by using a permanent control for control regions and a regionally switching parameter for loss control regions. This leads to a discontinuous dynamics framework, fitting into optimal control problems involving spatially heterogenous dynamics[2],[5]. The hybrid maximum principle (HMP, in short) extends the PMP to hybrid settings[2],[5], with a piecewise absolutely continuous adjoint vector.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Numerical contribution. In this note we illustrate a two-step numerical method for optimal control problems with loss control regions. First, a direct numerical approach is applied to a regularized problem to manage discontinuities and outline the optimal trajectory's structure. Second, this helps initialize an indirect numerical method for the original problem, using the PMP with loss control regions. The method incorporates the averaged Hamiltonian gradient condition[3],[4] and adjoint vector discontinuities to define an appropriate shooting function, adding to classical terms for non-hybrid optimal control problems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Contents\nProvide a statement of the PMP with loss control regions.\nProvide a direct method for solving optimal control problems with loss control regions (based on a regularization technique).\nProvide an indirect method (shooting method) for solving optimal control problems with loss control regions using the PMP with loss control regions.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: L. S. Pontryagin, V. G. Boltyanskii, R. V. Gamkrelidze, E. F. Mishchenko, The Mathematical Theory of Optimal Processes, A Pergamon Press Book. The Macmillan Co., New York, 1964.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2]: T. Bayen, A. Bouali, L. Bourdin & O. Cots, Loss control regions in optimal control problems, Journal of Differential Equations, 405 (2024), 359-397.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[3]: P. Bettiol, L. Bourdin, Pontryagin Maximum Principle for State Constrained Optimal Sampled-Data Control Problems on Time Scales, ESAIM Control Optim. Calc. Var., 27 (2021) 51.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[4]: L. Bourdin, G. Dhar, Optimal Sampled-Data Controls with Running Inequality State Constraints: Pontryagin Maximum Principle and Bouncing Trajectory Phenomenon, Mathematical Programming, 191 (2022) 907–951.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[5]: T. Haberkorn, E. Trélat, Convergence Results for Smooth Regularizations of Hybrid Nonlinear Optimal Control Problems, SIAM Journal on Control and Optimization, 49 (2011) 1498–1522.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"}]
}
