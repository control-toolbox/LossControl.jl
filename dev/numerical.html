<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical approach · Control loss</title><meta name="title" content="Numerical approach · Control loss"/><meta property="og:title" content="Numerical approach · Control loss"/><meta property="twitter:title" content="Numerical approach · Control loss"/><meta name="description" content="Documentation for Control loss."/><meta property="og:description" content="Documentation for Control loss."/><meta property="twitter:description" content="Documentation for Control loss."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://control-toolbox.org/assets/css/documentation.css" rel="stylesheet" type="text/css"/><script src="https://control-toolbox.org/assets/js/documentation.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Control loss</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="statement.html">Statement of the problem</a></li><li class="is-active"><a class="tocitem" href="numerical.html">Numerical approach</a><ul class="internal"><li><a class="tocitem" href="#Description-of-the-direct-method"><span>Description of the direct method</span></a></li><li><a class="tocitem" href="#Description-of-the-indirect-method"><span>Description of the indirect method</span></a></li></ul></li><li><a class="tocitem" href="zermelo1.html">Zermelo navigation problem: Example 1</a></li><li><a class="tocitem" href="zermelo2.html">Zermelo navigation problem: Example 2</a></li><li><a class="tocitem" href="ho.html">Harmonic oscillator problem</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="numerical.html">Numerical approach</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="numerical.html">Numerical approach</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/control-loss" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/control-loss/blob/main/docs/src/numerical.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-numerical-approach-for-optimal-control-problems-with-loss-control-regions"><a class="docs-heading-anchor" href="#A-numerical-approach-for-optimal-control-problems-with-loss-control-regions">A numerical approach for optimal control problems with loss control regions</a><a id="A-numerical-approach-for-optimal-control-problems-with-loss-control-regions-1"></a><a class="docs-heading-anchor-permalink" href="#A-numerical-approach-for-optimal-control-problems-with-loss-control-regions" title="Permalink"></a></h1><p>In optimal control theory, there are several ways for solving numerically an optimal control problem. Direct and indirect methods represent an important class of methods that we will use hereafter. </p><p>Direct methods involve discretizing the state and control variables, simplifying the problem into a finite-dimensional nonlinear optimization problem. On the other hand, indirect methods tackle the problem by solving a boundary value problem, based on the PMP, through the use of a shooting method (see, e.g.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>,<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>). </p><p>It is important to note that neither of these methods is fundamentally better than the other. Indeed, each of these methods has its pros and cons. For instance, although the direct method is simple to implement, more robust and less sensitive to the choice of the initial condition, it should be noted that it yields less precise results and can converge to local minima that significantly deviate from the optimal solution. Additionally, this method requires a large amount of memory. On the other hand, the indirect method is known for its extreme precision. However, it is based only on necessary optimality conditions from the PMP and often requires knowledge of the structure of the optimal solution. Moreover, it is quite sensitive to the choice of the initial condition, which must be chosen carefully to ensure convergence.</p><p>Often in the literature, one proceeds in two steps. The first step is to implement a direct method to determine the optimal solution&#39;s structure and extract the associated adjoint vector. The second step involves constructing an indirect shooting method, where the initial condition is based on the numerical results obtained from the direct method.</p><h2 id="Description-of-the-direct-method"><a class="docs-heading-anchor" href="#Description-of-the-direct-method">Description of the direct method</a><a id="Description-of-the-direct-method-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-the-direct-method" title="Permalink"></a></h2><p>For some <span>$\omega_0 \in \mathrm{U}$</span>, some <span>$\varepsilon_0&gt;0$</span> and <span>$\varepsilon&gt;0$</span> small enough, we introduce the <em>regularized problem</em> given by</p><p class="math-container">\[\begin{equation}
\begin{array}{lcl}
     \text{minimize}&amp;  &amp; \phi(x(0),x(T)) + \varepsilon_0 \displaystyle\int_0^T v^2(t) \, dt + \displaystyle\int_0^T (1- \Psi_{\varepsilon}(x(t)))\|u(t)-\omega_0\|_{\R^m}^2 \, dt,\\[10pt]
     \text{subject to}&amp; &amp;  (x,\lambda,u,v) \in \mathrm{AC}([0,T],\R^n) \times \mathrm{AC}([0,T],\R^m) \times \mathrm{L}^\infty([0,T],\R^m)\times \mathrm{L}^\infty([0,T],\R), \\[2pt]
     &amp; &amp; \dot{x}(t) = \Psi_{\varepsilon}(x(t)) f(x(t),u(t)) + (1-\Psi_{\varepsilon}(x(t))) f(x(t),\lambda(t)), \quad \text{a.e.\ } t\in [0,T], \\[2pt]
     &amp; &amp; \dot{\lambda}(t) =\Psi_{\varepsilon}(x(t))v(t), \quad \text{a.e.\ } t\in [0,T], \\[2pt]
     &amp;  &amp; g(x(0),x(T)) \in \mathrm{S}, \\[2pt]
     &amp;  &amp; \lambda(t)   \in \mathrm{U}, \quad \text{a.e.\ } t\in [0,T],\\[2pt]
     &amp;  &amp; (u(t),v(t)) \in  \mathrm{U} \times \R , \quad \text{a.e.\ } t\in [0,T],
     \end{array}
\end{equation}\]</p><p>where <span>$\Psi_{\epsilon} : \R^n \to \R$</span> is the regularization of the characteristic function of <span>$\cup_{q_j = 1} \overline{X_j}$</span> given by </p><p class="math-container">\[\Psi_{\varepsilon}(x) := \sum_{q_j = 1} e^{-\frac{1}{2 \varepsilon} \mathrm{d}^2_{j}(x)},\]</p><p>for all <span>$x\in \R^n$</span>, where <span>$\mathrm{d}_{j}: \R^n \to \R$</span> stands for the distance function to the set <span>$\overline{X_j}$</span> defined by <span>$\mathrm{d}_{j}(x) := \inf_{y \in \overline{X_j}} \|x-y\|_{\R^n}$</span> for all <span>$x\in \R^n$</span> and every <span>$j \in \mathcal{J}$</span>. </p><h2 id="Description-of-the-indirect-method"><a class="docs-heading-anchor" href="#Description-of-the-indirect-method">Description of the indirect method</a><a id="Description-of-the-indirect-method-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-the-indirect-method" title="Permalink"></a></h2><p>Recall that the direct method has captured the structure of the optimal pair <span>$(x^*,u^*)$</span>. In the indirect method, we address each arc separately.  We begin by defining the <strong>flow</strong> of the Hamiltonian associated with each arc. To accomplish this, we use the function <code>Flow</code> that can be found in the <a href="https://github.com/control-toolbox/CTFlows.jl">CTFlows.jl</a> package. This latter allows to solve the Hamiltonian system over a given time interval from given initial values of the state and the adjoint vector. This function requires necessary libraries such as  ForwardDiff for calculating gradients and Jacobians and  OrdinaryDiffEq for solving ordinary differential equations. </p><p>In the setting of the present paper (including control regions and loss control regions), we distinguish between two types of Hamiltonian flows:</p><ul><li><strong>Hamiltonian flows in control regions</strong> We recall that the Hamiltonian  <span>$H$</span> associated with the optimal control problem given above is defined by</li></ul><p class="math-container">\[H(x,u,p) := \langle  p, f(x,u)\rangle_{\R^n},\]</p><p>for all <span>$(x,u,p)\in \mathbb{R}^n \times \mathbb{R}^m \times \mathbb{R}^n$</span>. Using the theorem given above and more specifically the Hamiltonian maximization condition, we obtain an expression of the control <span>$u^*$</span> which can generate a sequence of arcs. Then it remains to define a <strong>pseudo-Hamiltonian</strong> (the pseudo-Hamiltonian stands for the Hamiltonian flow associated with each arc). associated with each arc. Finally we define the flow associated with each arc, which allows the resolution of the boundary value problem on a time interval satisfied by the pair <span>$(x^*,p)$</span> with an initial condition.</p><ul><li><strong>Hamiltonian flows in loss control regions</strong> Recall that, in loss control regions,  <span>$u^*$</span> satisfies an averaged Hamiltonian gradient condition (see Theorem above). Here, the difficulty lies in the fact that this condition is given in an integral and implicit form. Therefore, to overcome this difficulty, we first introduce new states  <span>$\lambda$</span> and  <span>$y$</span>. First, the state <span>$\lambda$</span> comes from the augmentation technique (we refer to <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> for more details) to handle the constant value  <span>$u^*_k$</span>, so it satisfies the dynamics  <span>$\dot{\lambda}(t)=0$</span> and the initial condition  <span>$\lambda(\tau^*_{k-1}) = u^*_k$</span>. Second, the state <span>$y$</span> satisfies <span>$\dot{y}(t) = 0$</span> and <span>$y(\tau^*_{k-1})=0$</span> (and thus <span>$y=0$</span>). Now we define the new Hamiltonian  <span>$\tilde{H}$</span> as follows:</li></ul><p class="math-container">\[\tilde{H}(x,u,y,p) 
            := H(x,u,p) - y \nabla_{u} H(x,u,p) = \langle  p, f(x,u)\rangle_{\R^n} - y \nabla_{u} H(x,u,p),\]</p><p>for all  <span>$(x,u,y,p)\in \mathbb{R}^n \times \mathbb{R}^m \times \R \times \mathbb{R}^n $.  It is important to note that, since $y=0$</span>, we recover the same Hamiltonian  <span>$H$</span>. But, the actual utility of introducing the state  <span>$y$</span> is that it allows us to rewrite the integral expressed in the averaged Hamiltonian gradient condition as a terminal value of an adjoint vector. This makes it easier to take into account in the shooting function. Here is the justification of this point. First, we define  <span>$p_{y}$</span> as the solution to the  system</p><p class="math-container">\[    \left\{\begin{array}{l}
     \dot{p}_{y}(t) = - \nabla_y \tilde{H}(x^*(t),u^*_k,y(t),p(t)), \quad
     \text{for a.e. } t\in [\tau^*_{k-1}, \tau^*_k],  \\
    {p}_{y}(\tau^*_{k-1}) = 0_{\R^n}.
    \end{array}
    \right.\]</p><p>Second, since  <span>$u_k^*$</span> is assumed to be an interior value to  <span>$\mathrm{U}$</span>, we get that</p><p class="math-container">\[\begin{equation*}
    \int_{\tau^*_{k-1}}^{\tau^*_k} \nabla_{u} H(x^*(t),u^*_k,p(t)) \, dt = {p}_{y}(\tau^*_k)=0.
\end{equation*}\]</p><p>Hence there is no need to compute an integral in order to take into account the averaged Hamiltonian gradient condition. </p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>S. Aronna, F. Bonnans, P. Martinon, <em>A shooting algorithm for optimal control problems with singular arcs</em>, Journal of Optimization Theory and Applications, <strong>158</strong>, pp. 419–459, Springer, 2013.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>J.F. Bonnans, <em>The shooting approach to optimal control problems</em>, IFAC Proceedings Volumes, <strong>46</strong>, no. 11, pp. 281–292, Elsevier, 2013.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>T. Bayen, A. Bouali, L. Bourdin &amp; O. Cots, <em>Loss control regions in optimal control problems</em>, Journal of Differential Equations, <strong>405</strong> (2024), 359-397.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="statement.html">« Statement of the problem</a><a class="docs-footer-nextpage" href="zermelo1.html">Zermelo navigation problem: Example 1 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Sunday 25 August 2024 12:33">Sunday 25 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
